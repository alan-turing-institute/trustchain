{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Trustchain","text":"<p>Welcome to the Trustchain Docs website.</p> <p>Trustchain is a decentralised approach to public key infrastructure, which builds on the W3C standards for Decentralised Identifiers (DID) and Verifiable Credentials (VC).</p> <p>These two standards are closely linked: verifying a credential involves resolving the issuer's DID document and performing a verification procedure using material contained in that document. Typically the verification material is a cryptographic public key, in which case the procedure is to use the key to verify the issuer's digital signature on the credential.</p> <p>Trustchain enables the creation of DIDs which are themselves verifiable. Via this mechanism, chains of trustworthy DIDs can be constructed in which downstream DIDs (dDIDs) contain an attestation from an entity represented by an upstream DID (uDID). It also enables a root DID to be securely established, so that downstream DIDs can be verified by tracing their chain of attestions back to the recognised root.</p> <p>Trustchain is free and open source software. The setup and operational costs of the system are low, without compromising on security or resilience, because it is built upon existing, robust peer-to-peer networks. It is globally accessible and can operate at any social scale, making it freely available for any user community to adopt.</p> <p> </p>"},{"location":"#trustchain-mobile","title":"Trustchain Mobile","text":"<p>Trustchain Mobile is a mobile app built to demonstrate the Trustchain user experience from the perspective of a holder and/or verifier of digital credentials. It is a fork of the Credible credential wallet app developed by SpruceID.</p>"},{"location":"#useful-links","title":"Useful links","text":"<ul> <li>Trustchain repository (GitHub)</li> <li>Trustchain Mobile repository (GitHub)</li> <li>Trustchain article</li> <li>Trustchain wiki</li> </ul>"},{"location":"acknowledgements/","title":"Acknowledgements","text":"<p>Trustchain was developed at the Alan Turing Institute, the UK's national institute for data science and artificial intelligence.</p> <p>This work was supported, in whole or in part, by the Bill &amp; Melinda Gates Foundation [INV-001309].</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Trustchain is free and open source software, and we welcome contributions from open source developers.</p> <p>If you would like to contribute, please take a look at our open issues.</p>"},{"location":"demo/","title":"Demonstration","text":"<p>This page outlines a demonstration of the Verifiable Credentials use case. To run the demonstration, checkout branch <code>demos/aiuk24</code> on both the Trustchain and Trustchain Mobile repositories.</p>"},{"location":"demo/#scenario","title":"Scenario","text":"<p>For this demonstration we assume a scenario in which Trustchain is deployed at a national scale, to support a trustworthy and privacy-preserving digital identity system. The corresponding network of decentralised identifiers (DIDs) is depicted in the following figure.</p> <p>In this scenario, the central government is the natural choice for the legal entity represented in the root DID. We stress, however, that this choice is merely an example intended to make for an easily relatable demonstration. In practice any organisation, public or private, may play this role.</p> <p>Each legal entity is represented digitally by its DID, which is depicted by a key icon because the essential content of the corresponding DID document is a set of cryptographic public keys (although URL endpoints are also included).</p> <p>With the exception of the root DID, each DID is signed by the immediate upstream entity, creating chains of verifiable public key certificates (downstream DIDs).</p> <p>The root DID itself carries no signature, because there is no upstream entity to provide such an attestation. Instead, the trustworthiness of the root DID is guaranteed by its independently-verifiable timestamp. This is depicted in the figure by a calendar icon.</p> <p> </p> Figure: Trustchain DID network in a national digital ID scenario"},{"location":"demo/#storyboard","title":"Storyboard","text":"<p>Each participant is assumed to have access to a mobile device with the Trustchain Mobile credential wallet app installed. The demonstration takes the user through the process of onboarding, configuring the app, receiving and verifying one or more digital credentials, and finally generating a verifiable presention (as a displayed QR code) which can be read and verified by another participant using the same mobile app.</p> <p>Trustchain Mobile is a fork of the Credible credential wallet app developed by SpruceID.</p>"},{"location":"demo/#onboarding","title":"Onboarding","text":"<p>When the Trustchain Mobile app is run for the first time, the user is presented with the onboarding process.</p> <p> </p> <p>The first step in this process is to generate a recovery phrase: twelve randomly selected words from a fixed vocabulary. The user is instructed to write down these words and keep them in a safe and secure place, so they will be able to recover their personal DID if they lose access to the wallet on this device.</p> <p> </p> <p>After hitting continue, they are asked to enter three of the twelve words to confirm the recovery phrase has been correctly recorded.</p> <p> </p>"},{"location":"demo/#profile","title":"Profile","text":"<p>Having completed the onboarding stage, the user is taken to the Profile page.</p> <p> </p> <p>Their newly-generated personal DID is displayed near the bottom of this screen. This was constructed from a new public-private key pair, generated by the app using the recovery phrase as a random seed. The user's personal DID encodes their public key via the <code>did:key</code> method. The user's private key was also stored securely on the device, to be used later for signing verifiable presentations.</p> <p> </p> <p>Near the top of the profile page, the user is directed by a green panel to enter the Settings page.</p> <p> </p>"},{"location":"demo/#configuration","title":"Configuration","text":"<p>Before using the app, one essential configuration step is necessary. The user must enter the root event date. That is, the date on which the root DID was published.</p> <p> </p> <p>This date is assumed to have been communicated to the user out-of-band by the legal entity represented in the root DID. Since the date on which Trustchain DIDs are published can be independently verified by all users, the timestamp on the root DID is the essential mechanism through which the user can be certain they have identified the legitmate root DID published by the genuine root entity, and not an imposter.</p> <p> </p> <p>A short 3-character confirmation code must also be entered at the same time as the root event date. This code identifies the specific Bitcoin transaction used to anchor the root DID.</p>"},{"location":"demo/#credential-wallet","title":"Credential Wallet","text":"<p>With the root DID configuration in place, the app is able to verify the signature of any legal entity whose DID is part of the user's network. It can therefore verify the authenticity of any downstream DID in the network and any credential issued by those entities.</p> <p> </p> <p>The user then scans a QR code that encodes a downstream DID, together with a path fragment that identifies a particular URL endpoint inside the DID document. This is the URL of an API endpoint for credential issuance.</p> <p> </p> <p>The app resolves the downstream DID in the QR code and verifies it by checking the chain of attestation signatures up to the root DID, and then verifying the root DID timestamp. If successful, the user can be certain of the identity of the issuing authority. They can then receive a verifiable credential, e.g. a digital university diploma as in this example.</p>"},{"location":"demo/#did-chain","title":"DID Chain","text":"<p>All credentials received by the app are automatically checked for authenticity.</p> <p>This involves verifying not only the signature of the issuing authority (and the credential expiry date), but also the attestation signatures on the chain of downstream DIDs and the timestamp on the root DID. The root DID timestamp is compared to the configured root event date (and the confirmation code). Only if all of these checks pass is the credential deemed valid.</p> <p>For maximum transparency, the user is also able to view the chain of downstream DIDs leading from the credential issuer back to the root entity. Each of the legal entities represented in this chain ought to be recognisable to the users, who can judge for themselves the level of trust they are willing to place in them, and the extent to which they are the appropriate authorities to be involved in the issuance of that particular type of credential.</p>"},{"location":"demo/#verifiable-presentation","title":"Verifiable Presentation","text":"<p>In the final step of the demonstration, the user generates a presentation from their credential, which can be verified using another device running the same Trustchain Mobile app.</p> <p>Typically a credential will contain multiple personal attributes relating to the holder, such as their name, nationality, date of birth, etc.</p> <p>Depending on the context, the user may wish to share only a subset of these attributes when presenting the credential. This is a key privacy benefit of digital ID systems (based on verifiable credentials) over traditional physical credentials which disclose all attributes to the verifier.</p> <p>Trustchain supports a redactable signature scheme which enables the user to selectively disclose only those attributes that they are willing to share.</p> <p> </p>"},{"location":"demo/#device-to-device-verification","title":"Device-to-Device Verification","text":"<p>When the user has selected the attributes for sharing, the app generates a presentation in which all other attributes are redacted, but which still contains a valid signature from the credential issuer. The presentation is also timestamped and signed using holder's private key, to prevent stale presentations from being re-used.</p> <p>The app then encodes this presentation in a QR code which is displayed on the device.</p> <p>Any other device running Trustchain Mobile can then scan this QR code and verify the authenticity of the credential from which it was generated.</p> <p>Naturally, the verifier's app must be configured with the same root event date as the credential holder's. This common knowledge of the root event date across all users of the network of trusted DIDs is a fundamental assumption on which Trustchain relies.</p> <p> </p>"},{"location":"deployment/","title":"Deployment","text":""},{"location":"dev-guide/","title":"Developer Guide [DRAFT]","text":""},{"location":"dev-guide/#project-structure","title":"Project Structure","text":"<p>The Trustchain codebase consists of four repositories:</p> <ul> <li>trustchain: Rust API and core reference implementation, CLI, HTTP, and FFI.</li> <li>trustchain-gui: Desktop GUI for mirroring CLI functionality.</li> <li>trustchain-mobile: Mobile credential wallet forked from credible (now called wallet)</li> <li>trustchain-dart: common Dart library code for errors and widgets.</li> </ul> <p>And a fork of the spruceid/ssi repository:</p> <ul> <li>ssi: Changes on the fork are described in detail in the PR notes:<ul> <li>New Redactable Signature scheme added, allowing selective disclosure for Verifiable Credentials.</li> <li>TODO: mention the IPFS-linked key feature added to support &gt;1kB RSS public keys. The ION DID method imposes a 1kB limit on DID deltas, making it impossible to publish RSS keys directly in ION DID documents.<ul> <li>Unit test in <code>trustchain-api/src/api.rs</code> called <code>get_key_entry()</code> can be used to print a <code>PublicKeyEntry</code> which is the type uploaded to IPFS.</li> </ul> </li> </ul> </li> </ul>"},{"location":"dev-guide/#code-repositories","title":"Code Repositories","text":""},{"location":"dev-guide/#trustchain","title":"Trustchain","text":"<p>The main <code>trustchain</code> repository contains the following Rust crates (details of which are given in the section below):</p> <ul> <li><code>trustchain-core</code>: Core logic, agnostic to implementation-specific components</li> <li><code>trustchain-ion</code>: Implementation of Trustchain for the ION DID method</li> <li><code>trustchain-cli</code>: Trustchain command line interface</li> <li><code>trustchain-ffi</code>: Foreign Function Interface</li> <li><code>trustchain-http</code>: Trustchain HTTP APIs</li> </ul>"},{"location":"dev-guide/#trustchain-gui","title":"Trustchain GUI","text":"<p>The <code>trustchain-gui</code> repository contains a Flutter application (written in Dart) which wraps the <code>trustchain</code> repository, and serves as the Trustchain desktop application.</p>"},{"location":"dev-guide/#trustchain-mobile","title":"Trustchain Mobile","text":"<p>The <code>trustchain-mobile</code> repository is a fork of the Credible credential wallet developed by SpruceID (also using Flutter/Dart), tailored to work with Trustchain.</p>"},{"location":"dev-guide/#trustchain-dart","title":"Trustchain Dart","text":"<p>The <code>trustchain-dart</code> repository contains platform agnostic dart code to be shared across platform specific application repositories (eg. <code>trustchain-mobile</code> and <code>trustchain-gui</code>). Including but not limited to shared ui and ffi error handling.</p>"},{"location":"dev-guide/#ssi-forked-from-spruceid","title":"SSI (Forked from SpruceID)","text":"<p>This is the main upstream library on which the Trustchain codebase depends.</p>"},{"location":"dev-guide/#rust-crates","title":"Rust Crates","text":"<p>Where required, configurable variables within crates are managed according to the configuration convention.</p>"},{"location":"dev-guide/#trustchain-core","title":"trustchain-core","text":""},{"location":"dev-guide/#error-handling","title":"Error handling","text":"<ul> <li>Enums<ul> <li>Implement <code>std::error::Error</code> with <code>thiserror</code> crate</li> <li>Add variants that wrap other errors (e.g. SSI error) so they can be passed</li> <li>Where possible do not convert error to string</li> <li>One variant pattern with extra context is:<ul> <li><code>MyError::Variant(String, ErrorTypeToWrap)</code></li> <li> </li> </ul> </li> </ul> </li> </ul>"},{"location":"dev-guide/#todo-add-example","title":"TODO: add example","text":""},{"location":"dev-guide/#immutable-verifier","title":"Immutable verifier","text":"<ul> <li>TODO: add info on <code>Mutex</code> and <code>Arc</code> from issue 89</li> <li>Principle: lock at lowest possible level to avoid bottlenecks</li> <li>Thread safe shared ownership with <code>Arc</code> and mutability with <code>Mutex</code></li> </ul>"},{"location":"dev-guide/#trustchain-ion","title":"trustchain-ion","text":""},{"location":"dev-guide/#trustchain-cli","title":"trustchain-cli","text":"<p>Install with: <pre><code>cargo install --path crates/trustchain-cli\n</code></pre></p>"},{"location":"dev-guide/#creating-a-did","title":"Creating a DID","text":"<pre><code>trustchain-cli did create --verbose --file ~/.trustchain/doc_states/my_doc_state.json\n</code></pre> <p>Checking the queue on the ION node: <pre><code>&gt; use ion-testnet-core\n&gt; db\nion-testnet-core\n&gt; db[\"queued-operations\"]\nion-testnet-core.queued-operations\n&gt; db.getCollectionNames()\n[\n        \"confirmations\",\n        \"operations\",\n        \"queued-operations\",\n        \"service\",\n        \"transactions\",\n        \"unresolvable-transactions\"\n]\n&gt; db[\"queued-operations\"].count()\n1\n</code></pre></p>"},{"location":"dev-guide/#attesting-to-did","title":"Attesting to DID","text":"<pre><code>trustchain-cli did attest --did UPSTREAM_DID --controlled_did DOWNSTREAM_DID\n</code></pre>"},{"location":"dev-guide/#verify","title":"Verify","text":"<pre><code>trustchain-cli did verify --did DOWSTREAM_DID_TO_VERIFY\n</code></pre> <p>E.g. for Turing: <pre><code>cargo run --bin trustchain-cli -- did verify --did did:ion:test:EiDSE2lEM65nYrEqVvQO5C3scYhkv1KmZzq0S0iZmNKf1Q\n</code></pre></p>"},{"location":"dev-guide/#publish-dids","title":"Publish DIDs","text":"<p>Run: ```bash! ./scripts/publish.sh <pre><code>and all operations in the `~/.trustchain/operations/*` will be posted to the ION server at `localhost:3000`.\n\n__You then need to manually move the operations (once satisifed published ok) to ~/.trustchain/operations/sent/./__\n```bash\nmv ~/.trustchain/operations/*.json* ~/.trustchain/operations/sent/./\n</code></pre></p>"},{"location":"dev-guide/#trustchain-ffi","title":"trustchain-ffi","text":"<ul> <li>Modules:<ul> <li><code>mobile</code></li> <li><code>gui</code></li> </ul> </li> <li>Each module has a set of free functions that are to be called on the Dart side</li> <li>Functions have a return type <code>anyhow::Result&lt;String&gt;</code> so that error handling can be sent over FFI</li> </ul>"},{"location":"dev-guide/#todo-remove-as-outdated-old-notes-from-trustchain-mobile-set-up-for-ffi","title":"(TODO: remove as outdated) Old notes from <code>trustchain-mobile</code> set-up for FFI","text":""},{"location":"dev-guide/#trustchain-ffi-with-flutter-rust-bridge","title":"Trustchain FFI with flutter rust bridge","text":"<p>Provides Trustchain functionality in credible with FFI through <code>flutter_rust_bridge</code>.</p>"},{"location":"dev-guide/#install","title":"Install","text":"<p>The below steps follow the guide in section 5:</p> <ul> <li>Clone trustchain to a path adjacent to credible root path.</li> <li>Install cargo dependencies: <pre><code>cargo install flutter_rust_bridge_codegen@1.64.0\n</code></pre></li> <li>Follow android instructions</li> <li>Add targets: <pre><code>rustup target add \\\n    aarch64-linux-android \\\n    armv7-linux-androideabi \\\n    x86_64-linux-android \\\n    i686-linux-android\n</code></pre></li> <li>Add <code>ANDROID_NDK</code> as a gradle property: <pre><code>echo \"ANDROID_NDK=(path to NDK)\" &gt;&gt; ~/.gradle/gradle.properties\n</code></pre></li> <li>Install <code>cargo ndk</code>: <pre><code>cargo install cargo-ndk --version 2.6.0\n</code></pre></li> </ul>"},{"location":"dev-guide/#build","title":"Build","text":"<p>With an android emulator, build can be completed from credible root with: <pre><code>flutter run\n</code></pre> Upon any modifications to the Trustchain Rust API, the FFI needs to be rebuilt with: <pre><code>flutter_rust_bridge_codegen \\\n    -r ../trustchain/trustchain-ion/src/api.rs \\\n    -d lib/bridge_generated.dart\n</code></pre></p>"},{"location":"dev-guide/#trustchain-http","title":"trustchain-http","text":"<ul> <li>Three functionalities are provided in initial crate:<ul> <li>Issuer of credentials</li> <li>Verifier</li> <li>Trustchain resolver/chain/CR</li> </ul> </li> <li>The server is run from a binary running an axum app inside a tokio async runtime<ul> <li><code>#[tokio::main]</code> for async main</li> <li><code>#[tokio::test]</code> for async test</li> </ul> </li> <li>Use axum for server impl (this uses <code>hyper</code> behind the scenes). Actix will not play nicely mixed with axum/hyper but can't remember why!</li> <li>Use <code>reqwest</code> over <code>hyper</code> for client requests</li> <li>Use traits for API definition and then impl for a struct to bring handler methods. These handler methods return <code>impl IntoResponse</code> an axum type that makes the everything easy to connect together. Very similar to FFI but not free functions.</li> <li><code>TrustchainHTTPAPI</code> trait returns <code>Result&lt;T, TrustchainHTTPError&gt;</code></li> <li>Handler methods convert <code>Result&lt;T, TrustchainHTTPError&gt;</code> into <code>impl Response</code> with the power of <code>impl IntoResponse for Result&lt;T, E&gt;</code> already implemented.</li> <li><code>TrustchainHTTPError</code> will:<ul> <li>Have variants corresponding to different HTTP status error types (e.g. Internal server error) but also have variants that wrap other Trustchain errors (e.g. <code>VerifierError</code>)</li> <li>Will have an <code>impl IntoResponse for TrustchainHTTPError</code> (see initial implementation passing on the <code>TrustchainHTTPError</code> as a <code>String</code> along with a <code>StatusCode</code>). By implementing the <code>axum</code> crate's <code>IntoResponse</code>, we can explicitly map each variant to a <code>StatusCode</code> and benefit from being able to directly return types: <code>Result&lt;T: IntoResponse, TrustchainHTTPError&gt;</code>.</li> </ul> </li> <li>A shared AppState is made available  to the handlers (e.g. for DIDChain handler). This allows anything in the state struct (currently a <code>ServerConfig</code> struct and an <code>IONVerifier</code>) to be used inside the handler. The <code>AppState</code>, as it does not implement <code>Clone</code> (the <code>IONVerifier</code> field cannot impl <code>Clone</code> and should be only be borrowed anyway as it contains a cache), needs to be passed into the shared state with an atomic reference counter. The <code>IONVerifier</code> is wrapped in a tokio read-write lock (<code>RWLock</code>) so that it can be mutable to allow data to be stored but so that race conditions are avoided within the async context we are using it. In practice, this means that when it is used inside a handler, a call to either make the lock read or write if mutability is required. <code>RWLock</code> is preferred over <code>Mutex</code> so that we only lock the <code>IONVerfier</code> when a write is required as opposed to when only read is required (as a resolver). We could implement a separate resolver field too inside the <code>AppState</code> and just use a <code>Mutex</code> if preferred. We could also revert to making <code>IONVerifier</code> instances in each handler call if verification will \"lock out\" other requests waiting for it to be freed (this may be an issue calling IPFS for data not cached on the server's IPFS node).</li> <li>Tests:<ul> <li>One big integration test for each of the three: issuer, verifier, TC node purposes</li> <li>Q: Should we do lots of unit tests for each part???</li> </ul> </li> </ul>"},{"location":"dev-guide/#getting-started-with-trustchain-http","title":"Getting Started with trustchain-http","text":"<ul> <li>Set-up ssh config: Add the following config (with your azure key) to <code>~/.ssh/config</code> <pre><code>Host ion\n    HostName 51.104.16.53\n    User ionuser\n    IdentityFile ~/.ssh/&lt;YOUR_AZURE_KEY&gt;\n    LocalForward 3000 localhost:3000\n    LocalForward 18332 localhost:18332\n    LocalForward 27017 localhost:27017\n    LocalForward 5001 localhost:5001\n</code></pre> Then call: <pre><code>ssh ion\n</code></pre></li> <li>Start the ION node.</li> <li>Symlink from SharePoint <code>dot_trustchain</code> directory to <code>~/.trustchain</code>.<ul> <li>Find the absolute path to the <code>dot_trustchain</code> folder in your local OneDrive directory (eg. <code>/Users/&lt;my_user&gt;/Library/CloudStorage/OneDrive-TheAlanTuringInstitute/dot_trustchain</code>).</li> <li> <p><code>cd</code> to the desired target directory (eg. <code>~</code>), and symlink with:</p> <p><pre><code>ln -s /Users/&lt;my_user&gt;/Library/CloudStorage/OneDrive-TheAlanTuringInstitute/dot_trustchain .trustchain\n</code></pre> - Add the following to your shell profile (e.g. <code>~/.zshrc</code>) and source it. <pre><code># Trustchain\nexport TRUSTCHAIN_CONFIG=~/.trustchain/trustchain_config.toml\nexport TRUSTCHAIN_DATA=~/.trustchain/\n</code></pre> - Clone the <code>trustchain</code> repo and checkout a branch with the <code>trustchain-http</code> crate (currently <code>55-issuer-backend-traits</code>). - Run the server with: <pre><code>cargo run -p trustchain-http\n</code></pre> - Install Postman - Open the Postman workspace at: <code>~/.trustchain/postman_workspaces/*</code> - Test by executing the pre-loaded HTTP requests in the Postman workspace.</p> </li> </ul> </li> </ul> <p>Branches (at May 2023): - Current root for HTTP work: <code>55-issuer-backend-traits</code> - Implementing verifier routes: <code>55-issuer-backend-traits-verifier-todo</code> - Challenge-Response: <code>94-challenge-response</code></p>"},{"location":"dev-guide/#copying-dot-trustchain-to-a-vm","title":"Copying dot trustchain to a VM","text":"<pre><code>rsync -azvuv --prune-empty-dirs \\\n    /Users/sgreenbury/ati/trustworthy-id/dot_trustchain \\\n    ion:./ \\\n    --include='dot_trustchain/key_manager/*/signing_key.json' \\\n    --include='**/trustchain_config.toml' \\\n    --include='dot_trustchain/credentials/offers/*.json' \\\n    --include='dot_trustchain/presentations/requests/*.json' \\\n    --include='*/' --exclude='*'\n</code></pre>"},{"location":"dev-guide/#running-the-http-server-on-the-vm-over-https","title":"Running the HTTP server on the VM over https","text":"<ul> <li>Go trustchain repo, install from branch you would like to serve: <pre><code>cargo install --path crates/trustchain-http\n</code></pre></li> <li> <p>Allow the binary to access 443 without sudo: <pre><code>sudo setcap CAP_NET_BIND_SERVICE=+eip .cargo/bin/trustchain-http\n</code></pre> :::info Note: the above <code>setcap</code> command must be re-run whenever the trustchain-http crate is rebuilt. :::</p> </li> <li> <p>Then run the server with: <pre><code>trustchain-http\n</code></pre></p> </li> </ul>"},{"location":"dev-guide/#creating-a-new-http-endpoint-in-trustchain-http","title":"Creating a new HTTP endpoint in trustchain-http","text":"<ul> <li>Inside the <code>trustchain-http</code> crate, add a new route in the <code>TrustchainRouter</code> impl block in the <code>server.rs</code> module.</li> <li>Create a new module in the <code>trustchain-http</code> crate to handle request to the new route (or use an existing handler module). Add the new module in <code>lib.rs</code>.</li> <li>In the handler module, create a struct representing the information in the HTTP GET/POST request. This will destructure the strings in the request into Rust types and should have the annotations: <pre><code>#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(rename_all = \"camelCase\")]\n</code></pre></li> <li>Write an async \"backend trait\" (similar to the example in <code>TrustchainHTTP</code>). Each method in this trait must return a <code>Result</code> type in which the success and error types both implement <code>IntoResponse</code> (in which case the <code>Result</code> type itself automatically implements the same trait).</li> <li>Write a trivial struct for your implementations of the backend trait (similar to <code>pub struct TrustchainHTTPHandler {}</code>).</li> <li>Implement the backend trait for the new struct.</li> <li>Also inside the same struct that implements the backend trait, implement a handler method (that's not in the trait) to provide the glue between the route and the backend Rust code:<ul> <li>arguments must be \"extractors\" (e.g. <code>Path</code>, <code>Query</code>, <code>Json</code>, <code>State</code>, etc.) corresponding to the HTTP request. For instance, a query parameter (after a <code>?</code> in the HTTP POST request) requires a <code>Query</code> extractor.</li> <li>return type must be <code>impl IntoResponse</code></li> <li>In the body of the handler method, make a call to a Rust method in the \"backend trait\" (that's implemented for the same struct that contains the handler method).</li> <li>Note: handler methods could be free functions, but by convention we include them in the impl block for the same struct that implements the backend trait.</li> </ul> </li> <li>If you need new error variant, go to <code>trustchain-http/src/errors.rs</code> and make a new variant. Add a new block in the <code>impl IntoResponse</code> part, e.g.: <pre><code>            err @ TrustchainHTTPError::NoCredentialIssuer =&gt; {\n                (StatusCode::BAD_REQUEST, err.to_string())\n            }\n</code></pre></li> <li>Use the Axum test helper crate to create a unit test for your new endpoint:<ul> <li>Create a <code>tests</code> module as a child of you handler module and import The Axum test helper: <pre><code>    use axum_test_helper::TestClient;\n</code></pre></li> <li>Inside the <code>tests</code> module, create a new (async) test case for your endpoint. Annotate it with <code>#[tokio::test]</code>.</li> <li>Copy the boilerplate code from an existing test: <pre><code>    let app = TrustchainRouter::from(HTTPConfig::default()).into_router();\n    let uri = \"/&lt;your-endpoint&gt;\".to_string();\n    let client = TestClient::new(app);\n</code></pre></li> <li>Make the request to the client, e.g.: <pre><code>    let response = client.post(&amp;uri)\n        .json(&lt;your-POST-request-params&gt;)\n        .send()\n        .await;\n</code></pre></li> <li>This sends a request to a server instance running on a random ephemeral port (thank you Axum helper!)</li> <li>Add a test assertion, e.g.: <pre><code>assert_eq!(response.status(), 200)\nassert_eq!(response.text().await, \"Hello world!\")\n</code></pre></li> <li>Run the specific test in VS Code by clicking \"Run Test\" above the test case, or run the whole test suite using cargo.</li> </ul> </li> </ul>"},{"location":"dev-guide/#running-tests","title":"Running Tests","text":"<p>Tests are implemented at either: - module level within a library crate (unit test) - separate test path adjacent to the library crate integration tests</p> <p>Some tests require ION (IPFS, mongo, bitcoin) and trustchain nodes (trustchain-http) to be running locally. When this is the case, <code>#[ignored=\"A REASON\"]</code> should be placed above the <code>fn test_fn()</code>: <pre><code>#[test]\n#[ignored=\"A REASON\"]\nfn test_fn() {\n    // ...\n}\n</code></pre></p>"},{"location":"dev-guide/#set-up","title":"Set-up","text":"<ul> <li>TODO: add description of init()</li> </ul>"},{"location":"dev-guide/#coding-conventions","title":"Coding Conventions","text":""},{"location":"dev-guide/#crate-configuration","title":"Crate Configuration","text":""},{"location":"dev-guide/#defining-config-variables","title":"Defining config variables","text":"<p>When handling configurable variables, a distiction has been made between crate-level constants, user-configurable variables, and environment variables. - Crate-level constants are defined in the <code>lib.rs</code> file at the root of the crate.     - They are part of the core funtionality of the crate and will be the same for all crate use cases.     - Any unit tests or integration tests may depend on these constants, as they are part of the core funtionality of the crate. - User-configurable variables are defined in the <code>trustchain_config.toml</code> file.     - One configuration file is used for all of the Trustchain crates being used, with one section in the file for each crate being configured.     - The may only be used in ignored tests (annotated with <code>#[ignore = \"&lt;Reason for ignore&gt;\"</code>), because they depend on the user setting an enviornment variable, <code>TRUSTCHAIN_CONFIG</code>, that points to a valid <code>trustchain_config.toml</code> file.     - An example <code>trustchain_config.toml</code> file for a project containing the <code>trustchain-core</code> and <code>trustchain-myexample</code> crates only, would have the following structure:         <pre><code>[core]\ndummy_variable_1 = 12345\n\n[myexample]\ndummy_variable_2 = 123456\ndummy_variable_3 = \"dummy string\"\n</code></pre> - Environment variables are variables set in the calling shell that can be referenced in either library or binary code with <code>std::env::var(\"ENV_VARIABLE_NAME\")</code>. There are two in use and have corresponding <code>lib.rs</code> <code>&amp;str</code> constants:     - <code>TRUSTCHAIN_DATA</code>: this is the directory path for key manager and HTTP features (SSL certificates, credential store, etc).     - <code>TRUSTCHAIN_CONFIG</code>: this is the file path for the main Trustchain <code>.toml</code> configuration file. These may be set independently and during <code>cargo test</code> <code>TRUSTCHAIN_DATA</code> is set specifically to a tempdir location inside <code>init()</code>.</p>"},{"location":"dev-guide/#referencing-config-variables","title":"Referencing config variables","text":"<p>The convention for referencing the user-configurable variables in Rust code is to introduce a <code>config.rs</code> file at the root of the crate. The role of the file is to load the variables from <code>trustchain_config.toml</code> that relate to that crate. An example <code>config.rs</code> file for a new crate <code>trustchain-myexample</code> is as follows:</p> <pre><code>use crate::TRUSTCHAIN_CONFIG;\nuse lazy_static::lazy_static;\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse toml;\n\nlazy_static! {\n    /// Lazy static reference to core configuration loaded from `trustchain_config.toml`.\n    pub static ref MYEXAMPLE_CONFIG: MyexampleConfig = parse_toml(\n        &amp;fs::read_to_string(std::env::var(TRUSTCHAIN_CONFIG).unwrap().as_str())\n        .expect(\"Error reading trustchain_config.toml\"));\n}\n\n/// Parses and returns core configuration.\nfn parse_toml(toml_str: &amp;str) -&gt; MyexampleConfig {\n    toml::from_str::&lt;Config&gt;(toml_str)\n        .expect(\"Error parsing trustchain_config.toml\")\n        .core\n}\n\n/// Gets `trustchain-core` configuration variables.\npub fn myexample_config() -&gt; &amp;'static MYEXAMPLE_CONFIG {\n    &amp;MYEXAMPLE_CONFIG\n}\n\n/// Configuration variables for `trustchain-core` crate.\n#[derive(Serialize, Deserialize, PartialEq, Debug)]\npub struct MyexampleConfig {\n    /// Variables defined in the 'myexample' section of trustchain_config.toml\n    pub dummy_variable_2: u32,\n    pub dummy_variable_3: String\n}\n\n/// Wrapper struct for parsing the `myexample` table.\n#[derive(Serialize, Deserialize, PartialEq, Debug)]\nstruct Config {\n    /// Core configuration data.\n    myexample: MyexampleConfig,\n}\n</code></pre> <p>The above module exposes a function <code>myexample_config()</code> which is used elsewhere in the crate to access the variables: <pre><code>use crate::config::myexample_config;\n\nlet var_2 = myexample_config().dummy_variable_2\n</code></pre></p>"},{"location":"dev-guide/#use-of-config-variables","title":"Use of config variables","text":"<p>In library code, config variables should be passed as arguments to functions that depend on them, rather than accessing from a static reference (as described above).</p> <p>This avoids any dependency on local config files, which causes problems (e.g. when writing unit tests).</p> <p>For example, the <code>Verifier</code> API should look this this: <pre><code>pub fn new(resolver: Resolver&lt;T&gt;, config: &amp;IONConfig) -&gt; Self {\n// Construct a Bitcoin RPC client to communicate with the ION Bitcoin node.\n    let rpc_client = bitcoincore_rpc::Client::new(\n        &amp;config.bitcoin_connection_string,\n        bitcoincore_rpc::Auth::UserPass(\n            config.bitcoin_rpc_username.clone(),\n            config.bitcoin_rpc_password.clone(),\n        ),\n    )\n    // Safe to use unwrap() here, as Client::new can only return Err when using cookie authentication.\n    .unwrap();\n}\n</code></pre> and should not use a getter for the static reference, like this: <pre><code>// DON'T DO THIS!\npub fn new(resolver: Resolver&lt;T&gt;) -&gt; Self {\n// Construct a Bitcoin RPC client to communicate with the ION Bitcoin node.\n    let rpc_client = bitcoincore_rpc::Client::new(\n        &amp;config.bitcoin_connection_string,\n        bitcoincore_rpc::Auth::UserPass(\n            ion_config().bitcoin_rpc_username.clone(),\n            ion_config().bitcoin_rpc_password.clone(),\n        ),\n    )\n    // Safe to use unwrap() here, as Client::new can only return Err when using cookie authentication.\n    .unwrap();\n}\n</code></pre></p>"},{"location":"dev-guide/#error-handling_1","title":"Error Handling","text":""},{"location":"dev-guide/#use-of-map_error","title":"Use of <code>map_error</code>","text":"<p>Where error enums do not explicitly implement the <code>From&lt;T&gt;</code> conversion trait, use <code>.map_err()</code> followed by the question mark operator <code>?</code> to allow ergonomic error propagation.</p>"},{"location":"dev-guide/#error-enums","title":"Error enums","text":"<p>Module-specific error enums should be defined in the module. Error enums used in multiple modules within a crate should be defined in an <code>error.rs</code> module of the crate and make use of <code>thiserror</code> to simplify implementation.</p> <p><code>From&lt;T&gt;</code> can be implemented manually for types as currently in the <code>trustchain-http</code> crate but can also be more straightforwardly implemented with thiserror. See <code>KeyManagerError</code>.</p>"},{"location":"dev-guide/#ffi-error-handling-with-anyhowresultt","title":"FFI Error handling with <code>anyhow::Result&lt;T&gt;</code>","text":"<p>Notes: - <code>flutter_rust_bridge</code> currently does not support returning the Rust <code>Result</code> type over the bridge. Instead, returning <code>anyhow::Result&lt;T&gt;</code> is supported. - Whilst a generic over the error varient, <code>anyhow::Result&lt;T,E&gt;</code>, is supported by <code>anyhow</code>, the bridge only supports an <code>anyhow</code> error varient of type <code>anyhow::Error</code> (the shorthand for which is <code>anyhow::Result&lt;T&gt;</code>).</p> <p>How to implement: - <code>anyhow::Result&lt;String&gt;</code> and <code>anyhow::Result&lt;()&gt;</code> are to two return types used for any of the ffi functions (called from Dart). - The <code>String</code> option is flexible to cover any serialised Rust types. A Dart model with a deserialisation method will handle the json string on the Dart side. - See the example Rust code below, demonstrating an ffi function to be called by Dart: <pre><code>use thiserror::Error;\n\n#[derive(Error, Debug)]\nenum MyFFIError {\n\n    #[error(\"JSON Deserialisation Error: {0}.\")]\n    FailedToDeserialise(serde_json::Error),\n\n    #[error(\"My_func Error: {0}.\")]\n    FailedToDoIt(Box&lt;dyn std::error::Error&gt;),\n}\n\npub fn my_ffi_function(arg1: String) -&gt; anyhow::Result&lt;String&gt; {\n\n    match TrustchainAPI::my_function(&amp;arg1) {\n\n        Ok(my_answer) =&gt; Ok(serde_json::to_string_pretty(&amp;my_answer)\n            .expect(\"Serialize implemented for my_answer struct\")),\n\n        Err(err) =&gt; Err(anyhow!(\"{}\", MyFFIError::FailedToDoIt(err))),\n    }\n}\n</code></pre></p> <p>Some notes on the above: - Aligned with the wider convention on custom Error enums, <code>thiserror::Error</code> is derived with the <code>#[error(\"...\")]</code> macro. - Under the hood, the <code>anyhow!()</code> macro uses this to build the string passed over the bridge to Dart. - The error received by Dart will be: <code>\"My_func Error: &lt;Whatever the Boxed error returned from my_function was&gt;.\"</code> - Dart code can pattern match on the first part of the string, before the colon. - When implementing a new variant on an ffi error enum in Rust, a corresponding varient must be added to the dart <code>FfiError</code> enum, maintained in the <code>trustchain-dart</code> repository. - Under certain circumstances, it is possible to return <code>Err(MyFFIError::my_varient(err).into())</code> without using the <code>anyhow!()</code> macro. However, this shortcut will not work if <code>MyFFIError</code> contains varients wrapping <code>Box&lt;dyn Error&gt;</code> (boxed trait objects). - In line with the wider convention on error handling, it is possible to have a custom error enum wrapping a tuple <code>(String, Error)</code>, in order to provide some additional information: <pre><code>#[error(\"JSON Deserialisation Error: {1} \\n Info: {0}\")]\n    FailedToDeserialiseVerbose(String, serde_json::Error),\n</code></pre></p>"},{"location":"dev-guide/#trustchain-mobile-details","title":"Trustchain Mobile details","text":"<p>Trustchain mobile installation instructions: https://github.com/alan-turing-institute/trustchain-mobile/blob/dev/install_trustchain_mobile.md</p>"},{"location":"dev-guide/#building-for-an-android-emulator","title":"Building for an Android emulator","text":"<p>TODO</p>"},{"location":"dev-guide/#building-app-for-android-physical-device","title":"Building app for Android physical device","text":"<ul> <li> <p>Build app: <pre><code>flutter build apk --debug --dart-define-from-file flutter-config.json\n</code></pre> with <code>flutter-config.json</code> containing a default endpoint, for example: <pre><code>{\n    \"trustchainEndpoint\": \"https://trustchain.uksouth.cloudapp.azure.com\",\n    \"rootEventTime\": \"&lt;YOUR_ROOT_EVENT_TIME&gt;\"\n}\n</code></pre></p> </li> <li> <p>Log in to trustchaindevstest google account:</p> </li> <li>Go to drive</li> <li>Upload the built apk to drive. Path should be: <pre><code>build/app/outputs/flutter-apk/app-debug.apk\n</code></pre></li> <li>Update shared permissions/access settings on google drive for the file to \"Share with anyone by link\"</li> <li>Copy link</li> <li> <p>Use e.g. <code>qrencode</code> command line util (or any QR code maker) to generate a QR code picture: <pre><code>brew install qrencode\nqrencode &lt;LINK&gt; -o qrcode.png\n</code></pre> A recent one is: https://drive.google.com/file/d/1tXvnOI8Zbqav-JwM2tKtuo84kGfVinBt/view</p> </li> <li> <p>Open with preview and scan from device to download the file</p> </li> <li>Open the APK and allow to install</li> </ul>"},{"location":"dev-guide/#trustchain-gui-details","title":"Trustchain GUI details","text":""},{"location":"dev-guide/#trustchain-dart-details","title":"Trustchain Dart details","text":"<p>In principal, front-end applications on all platforms should share as much code in Trustchain Dart as possible.</p> <p>This work was not completed. Trustchain Mobile currently does not depend on Trustchain Dart. Trustchain GUI does depend on Trustchain Dart, but there is some dupicate code between the two repositories.</p>"},{"location":"dev-guide/#platform-agnostic-error-handling","title":"Platform agnostic error handling","text":"<ul> <li><code>FfiError</code>, an extended dart enum, maps all Rust error variants returned over the ffi.<ul> <li>The enum variants contain string constants within them (analogous to Rust enums containing data).</li> <li>A static method on <code>FfiError</code>, called <code>parseFfiError()</code>, automatically supports any new enum variants added to FfiError and parses the serialised Rust errors into <code>FfiError</code> variants.</li> </ul> </li> </ul>"},{"location":"dev-guide/#dart-models-of-trustchain-structs","title":"Dart models of Trustchain structs","text":"<p>This work was not completed. - Platform agnostic dart models, constructable from serialised Rust structs.</p>"},{"location":"dev-guide/#shared-ui-widgets","title":"Shared UI widgets","text":"<p>This work was not completed. - Trustchain Mobile and Trustchain GUI use different dart widgets to display the same trustchain Rust structs. - Platform agnostic widgets could be shared and ensure consistent UI for applications on all platforms. - Palettes, styling and assets should be maintained in this repository to ensure consistency across applications on all platforms.</p>"},{"location":"dev-guide/#documentation","title":"Documentation","text":"<p>The Trustchain Docs documentation site is built with Material for MkDocs.</p>"},{"location":"dev-guide/#terminal-commands","title":"Terminal commands","text":"<p>All Terminal commands in the documentation should be rendered in full-line code blocks (not inline) and tagged with the identifier <code>console</code> after the three opening backticks. They should include the <code>$</code> character to indicate the command prompt.</p> <p>The prompt character helps to distinguish between Terminal commands and other code snippets that should not be entered at the command line, and is omitted when the \"Copy to clipboard\" icon is clicked (or the code is selected).</p> <p>For example, the Markdown code block: <pre><code>```console\necho \"hello, world\"\n```\n</code></pre> will be rendered as: <pre><code>echo \"hello, world\"\n</code></pre> but only the command <code>echo \"hello, world\"</code> will be copied to the clipboard.</p> <p>Info</p> <p>The feature to omit the command prompt character when copying to the clipboard is not implemented in Material for MkDocs. Instead it was added via custom Javascript following this approach.</p> <p> </p>"},{"location":"faq/","title":"FAQ","text":"<p>Welcome to the Trustchain frequently asked questions (FAQ) page.</p>"},{"location":"faq/#q-do-we-really-need-a-new-approach-to-public-key-infrastructure-why-not-use-the-existing-web-pki","title":"Q: Do we really need a new approach to public key infrastructure? Why not use the existing Web PKI?","text":"<p>In principle, public keys contained in X.509 certificates (and attested to by Certificate Authorities) could be used for the purpose of credential verification. However such a system cannot provide the level of trustworthiness necessary in the context of digital identity.</p> <p>The existing Web PKI suffers from known vulnerabilities, which have occasionally been exploited in the past. Some of these issues are described in a 2016 memo from the IETF, a review of which can be found here.</p> <p>But the fundamental problem with using the Web PKI for digital identity is the artificial nature of the trust relationships between Certificate Authorities and the entities they certify. They are artificial in the sense that there was no pre-existing relationship. Instead one has been manufactured on request, purely for the purpose of sharing public keys.</p> <p>As such, it is impossible for relying parties to evaluate the level of trust they should place in an entity simply because they are the subject of an X.509 certificate, or whether that entity is an appropriate authority to issue credentials of a particular kind.</p> <p>Contrast this to the hierarchical connections in Trustchain, which are digital representations of genuine trust relationships that already existed between recognisable and relatable entities in the physical world.</p>"},{"location":"faq/#q-what-is-meant-by-the-term-independently-verifiable-timestamping","title":"Q: What is meant by the term \"independently verifiable timestamping\"?","text":"<p>Timestamping refers to the process of attaching date/time information to a piece of data which serves as a proof that the data existed at that time. Verifiable timestamping means that there exists some mechanism by which that proof can be verified.</p> <p>Independently verifiable timestamping means that the mechanism used to verify a timestamp is available to anybody, and does not require any special knowledge or trust in any third party.</p> <p>For a full explanation of the timestamping process and verification mechanism, see this technical note.</p>"},{"location":"faq/#q-why-is-independently-verifiable-timestamping-important-in-trustchain","title":"Q: Why is independently verifiable timestamping important in Trustchain?","text":"<p>Trustchain builds on the Identity Overlay Network (ION), which itself leverages Bitcoin's proof of work mechanism to publish DID documents with independently verifiable timestamps.</p> <p>Crucially, the timestamp verification process can be performed by anyone, without requiring any prior knowledge on the part of the verifier (e.g. knowledge of a particular public key).</p> <p>Verifiable timestamping plays an important role in the design of Trustchain by enabling three core mechanisms:</p> <ol> <li> <p>Secure and efficient sharing of the root DID</p> <p>All participants in the system must agree on the same root DID which is to act as the root of trust for all downstream DID connections. How should this be achieved?</p> <p>The DID itself is typically a long string of base64-encoded characters, making it difficult to transcribe and easy to confuse. Therefore it can only realistically be shared by electronic means, and transcribed by copying &amp; pasting. However this raises the question of how users are to be confident that they have been sent the correct root DID, and not a fraudulent one.</p> <p>In Trustchain, verifiable timestamping provides a much simpler and more reliable way to share this vital information. Only the date on which the root DID was published needs to be shared, together with a short 3-character confirmation code (which is a fragment of the corresponding Bitcoin transaction ID).</p> <p>A calendar date is short enough, and familiar enough, to be shared via non-digital channels (incuding TV, radio, newspapers, physical notice boards and word of mouth). This means that the process of sharing/publicising the root DID need not depend on any existing public key infrastructure.</p> </li> <li> <p>Defence against root DID spoofing</p> <p>Since the data registry used to publish DID information is open and permissionless, there is a risk that an attacker might publish fake (or \"spoof\") DIDs which, if accepted as valid, could enable them to issue fraudulent credentials.</p> <p>The digital signatures on downstream DIDs prevent such an attack, but the root DID is unsigned so a different mechanism is required to avoid spoofing.</p> <p>We assume here that the date (and confirmation code) of the root DID are known to all participants, having been shared according to the procedure outlined in point 1 above.</p> <p>Under this assumption, the timestamp on the root DID completely neutralises any spoofing attack that takes place before or after the date on which the genuine root transaction was published. Although an attack is theoretically possible on the same date, any attack that takes place outside of that particular 24 hour period is nullified.</p> <p>This is good start, but in fact the advantage is much greater. After the 24 hours have elapsed, we can observe all of the DID transactions that were published on the same date as the root, and simply check that no \"spoof\" transaction exists whose confirmation code matches that of the genuine root transaction. Having done this, we can be certain that no attacker has published, or will ever publish, a fake root transaction that could be confused with our honest one.</p> </li> <li> <p>Guaranteed complete DID revocation checks</p> <p>Credential verifiers need to be confident that they have an up-to-date list of any DIDs that have been revoked. Imperfect revocation checking is recognised as a weak point in the Web PKI (see Section 3.2 of this IETF memo), but in Trustchain the fact that all DIDs are verifiably timestamped provides a guarantee that all revocation information, up to the time of the latest available Bitcoin block, is known.</p> <p>Bitcoin's chain of proof of work enables anyone to verify that they haven't missed any DID transactions in the middle of the chain. And verifiable timestamping makes it possible to verify that nothing has been missed off the end. One just needs to look at the timestamp of the most recent available block to be certain that all of the DID operations published up to that time have been observed.</p> <p>Verifiers can therefore be certain that they have received all revocation notifications up to a given time.</p> </li> </ol>"},{"location":"faq/#q-could-trustchain-be-implemented-on-a-proof-of-stake-blockchain-such-as-ethereum-instead-of-bitcoin","title":"Q: Could Trustchain be implemented on a proof-of-stake blockchain, such as Ethereum, instead of Bitcoin?","text":"<p>No, the Trustchain security model depends specifically on proof-of-work because it enables a timestamp verification mechanism that does not require any prior knowledge on the part of the verifier (as explained in this technical note). This enables any participant to confirm that the root DID was published on a particular date, which is how they can be certain it is genuine.</p> <p>In a proof-of-stake system, since there is no proof-of-work, the only verification mechanism available is the digital signature. Evidently, digital signatures are not suitable for sharing root public keys because another public key would be needed in advance, in order to verify the signature on the root certificate. Logically then, proof-of-stake cannot provide a mechanism for sharing a root public key.</p> <p>In particular, proof-of-stake does not enable independently verifiable timestamping. To see this, let us consider how the security of Trustchain would be affected if proof-of-work were to be replaced by proof-of-stake.</p> <p>Suppose the hash of a root DID were embedded in an Ethereum transaction instead of a Bitcoin transaction. Anyone running an Ethereum full node could verify that the transaction was included in a particular block, and they could read the timestamp on that block.</p> <p>But how can they be sure that the timestamp is accurate and the block was indeed published on the date claimed?</p> <p>They can verify that the block is contained in a proof-of-stake chain that meets the requirements specified by the Ethereum protocol. But how costly would it be for an attacker to produce a fraudulent chain which still meets these requirements?</p> <p>Since the protocol demands no computational work, the answer is that an attacker could very cheaply produce an alternative data structure that still constitutes a valid proof-of-stake chain. The only requirement is that it must contain a sequence of transaction data with appropriate digital signatures to conform to the Ethereum protocol. But digital signatures can be produced at essentially zero cost.</p> <p>To dissuade this sort of unwanted behaviour, the Ethereum protocol imposes a financial penalty on any participant that proposes multiple alternative chains (a measure known as \"slashing\"). However, this sanction can only be applied if the attacker has units of Ether (the ETH token) staked at the time the attack takes place. Therefore long-range attacks, after the attacker has withdrawn their staked Ether, are essentially costless.</p> <p>In this scenario the Trustchain user would have no way of verifying that the chain (and the timestamp) they are observing is genuine. It could be the original chain that was constructed at regular intervals over the preceding months and years, or it could be a new chain containing deceptive timestamps that appear to date back years. There is no way for the verifier to reliably and independently distinguish between these two possibilities.</p> <p>In the case of proof-of-work, the situation is very different. The attacker would need to redo all of the computational work that has been done by the network since the timestamp in question. At the time of writing (April 2025), the Bitcoin network continuously computes around \\(8\\times10^{20}\\) SHA-256 hash digests every second, which means the blockchain data structure itself is extremely (and verifiably) costly to produce. Therefore, while theoretically possible, an attack which rewrites the history of the Bitcoin blockchain is infeasible, particularly over timeframes of several months or years.</p> <p>For an in-depth analysis of the different security guarantees afforded by proof-of-work versus proof-of-stake, see Andrew Poelstra's 2015 article On Stake and Consensus.</p>"},{"location":"faq/#q-isnt-bitcoin-wasteful-does-trustchain-contribute-to-bitcoins-energy-consumption","title":"Q: Isn't Bitcoin wasteful? Does Trustchain contribute to Bitcoin's energy consumption?","text":"<p>The Bitcoin protocol employs the proof of work (PoW) mechanism to achieve consensus across a peer-to-peer network regarding the order of monetary transactions. This enables it to solve the double-spending problem without the need for any central authority. The result is a signal that is unforgeably costly to produce and can be independently verified by anybody.</p> <p>A similar mechanism can be observed in certain biological systems, a phenomenon known as the handicap principle. In this context, reliable signalling between individual animals is achieved through the apparent squandering of scarce resources to produce the signal.</p> <p>Like the handicapping behaviour that demonstrates biological fitness, proof of work may appear wasteful at first glance. However on closer inspection we see that the benefits accruing from the improved reliability of the signal outweigh the cost of the resources consumed in producing it. If this were not the case we would not observe the behaviour in the first place, since it would yield no economic (or biological) advantage.</p> <p>Trustchain (via the ION system) makes use of the same incorruptible signals generated by Bitcoin's proof of work to endow DID documents and metadata with independently verifiable timestamps, which form the basis of its security model. No new consumption of energy is needed because the work is already being done by the Bitcoin network. This implies a greater overall efficiency, since the same work is being put to greater use.</p> <p> </p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>The instructions below will guide you through the installation and configuration of the Trustchain software.</p> <p>Trustchain can be installed on all major operating systems. The steps below have been tested on Linux and macOS. On Windows the process will be similar, with instructions available via the links provided.</p> <p>Running commands in the Terminal</p> <p>This guide will make frequent use of the command line interface provided by the Terminal application, which is available on all operating systems.</p> <p>Commands will be presented in code blocks like this one: <pre><code>echo \"Hello World\"\n</code></pre> These are commands that you should copy and paste into your Terminal, followed by the Enter key to execute the command.</p> <p>To copy to the clipboard, click on the  icon at the right-hand side of the code block.</p>"},{"location":"getting-started/#environment-variables","title":"Environment Variables","text":"<p>As far as possible, we would like the Terminal commands given in this guide to work on any computer, so they can be copied and pasted without modification. This makes the installation process quicker and less error-prone. However, many commands depend on particular files or folders, which different users may wish to store in different locations.</p> <p>To solve this problem, we shall define environment variables to keep track of the location of relevant files and folders. An environment variable is just like a variable in any programming language. It enables us to use a generic and meaningful name to refer to something specific which is not known in advance (in this case the path to a particular file or folder).</p> <p>Environment variables are defined in your Terminal configuration file. Since we will need to edit this file several times during the installation, it will be convenient to have an environment variable containing its path on the file system.</p> <p>To do this, run the following command: <pre><code>SHELL_CONFIG=$(find ~/.*shrc -maxdepth 0 | head -n 1) &amp;&amp; echo \"export SHELL_CONFIG=$SHELL_CONFIG\" &gt;&gt; $SHELL_CONFIG\n</code></pre> Now check that the new environment variable exists: <pre><code>echo $SHELL_CONFIG\n</code></pre> This command should output the path to your Terminal configuration file. From now on, whenever we want to refer to that file we will be able to use the <code>SHELL_CONFIG</code> environment variable.</p> <p>Creating environment variables</p> <p>Now that we have defined the <code>SHELL_CONFIG</code> environment variable (above), we can use it to conveniently create new environment variables. Whenever we need to define a new variable, you will be given a command similar to the following (don't run this one, it's just an example): <pre><code>echo \"export NAME=VALUE\" &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre> This command adds a new environment variable named <code>NAME</code> with value <code>VALUE</code> to your Terminal config file, and then reads the updated file so the change takes effect inside the current Terminal session.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#step-1-install-ion","title":"Step 1. Install ION","text":"<p>As the main Trustchain dependency, ION has its own section on this site. Please follow the installation instructions provided on the ION page.</p>"},{"location":"getting-started/#step-2-install-rust","title":"Step 2. Install Rust","text":"<p>Instructions for installing the Rust language can be found here.</p> <p>On Linux or macOS, the recommended method is to run the following command: <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre></p> <p>Then check the installation was successful by running: <pre><code>rustc --version\n</code></pre></p>"},{"location":"getting-started/#step-3-install-trustchain","title":"Step 3. Install Trustchain","text":"<p>Choose a directory in which you want to store the Trustchain software and change to that directory using the command <code>cd &lt;DIRECTORY_NAME&gt;</code>. For instance, to change to your home directory run the <code>cd</code> command without any arguments: <pre><code>cd\n</code></pre> Now clone the Trustchain code repository from GitHub: <pre><code>git clone https://github.com/alan-turing-institute/trustchain.git\n</code></pre> and then enter the newly-created <code>trustchain</code> subfolder: <pre><code>cd trustchain\n</code></pre></p> <p>Create the <code>TRUSTCHAIN_REPO</code> environment variable</p> <p>Since we will need to refer to this folder in future, let's create an environment variable containing its file path: <pre><code>echo \"export TRUSTCHAIN_REPO=\" $(pwd) | sed 's/= /=/g' &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre></p> LinuxmacOS <p>The next step is to build the Trustchain software from its source code. It depends on the OpenSSL library, so let's make sure we have that installed first: <pre><code>sudo apt install openssl &amp;&amp; sudo apt install libssl-dev &amp;&amp; sudo apt install pkg-config\n</code></pre> Now we can build Trustchain (this may take a minute or two): <pre><code>cargo build\n</code></pre></p> <p>The next step is to build the Trustchain software from its source code (this may take a minute or two): <pre><code>cargo build\n</code></pre></p> <p>Finally, we install the Trustchain command line interface (CLI): <pre><code>cargo install --path crates/trustchain-cli\n</code></pre></p>"},{"location":"getting-started/#configuration","title":"Configuration","text":""},{"location":"getting-started/#trustchain-data-directory","title":"Trustchain data directory","text":"<p>Trustchain uses a data directory to store files related to its operation. Here we assume that the data directory will be <code>~/.trustchain</code>, but if you prefer to use a different one simply change the path in the following command when creating the <code>TRUSTCHAIN_DATA</code> environment variable.</p> <p>Create the <code>TRUSTCHAIN_DATA</code> environment variable</p> <pre><code>echo 'export TRUSTCHAIN_DATA=~/.trustchain/' &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre> <p>Now create the <code>TRUSTCHAIN_DATA</code> directory on your file system: <pre><code>mkdir $TRUSTCHAIN_DATA\n</code></pre></p>"},{"location":"getting-started/#trustchain-configuration-file","title":"Trustchain configuration file","text":"<p>Configuration parameters relating to Trustchain are stored in a file named <code>trustchain_config.toml</code>, which will be stored in the data directory (created above). Once again, we create an environment variable containing the path to this file.</p> <p>Create the <code>TRUSTCHAIN_CONFIG</code> environment variable</p> <pre><code>echo 'export TRUSTCHAIN_CONFIG=\"$TRUSTCHAIN_DATA\"trustchain_config.toml' &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre> <p>Copy the template configuration file from the Trustchain repository to the data directory (unless it already exists): <pre><code>cp -n $TRUSTCHAIN_REPO/trustchain_config.toml $TRUSTCHAIN_CONFIG\n</code></pre> and set appropriate user permissions: <pre><code>chmod 640 $TRUSTCHAIN_CONFIG\n</code></pre></p> <p>Then open your copy of <code>trustchain_config.toml</code> for editing: <pre><code>nano $TRUSTCHAIN_CONFIG\n</code></pre> This file is organised into different sections, separated by headings inside square brackets. At this point, we only need to consider the <code>[ion]</code> and <code>[cli]</code> sections.</p> <p>Edit the following configuration parameters:</p> <ul> <li>In the <code>[ion]</code> section, set the <code>mongo_database_ion_core</code> parameter to either <code>\"ion-mainnet-core\"</code> or <code>\"ion-testnet-core\"</code>, depending on the Bitcoin network in use (see the example below). This parameter must match the <code>databaseName</code> parameter in the ION Core config file which can be viewed by running the following command: <pre><code>cat $ION_CORE_CONFIG_FILE_PATH\n</code></pre></li> <li>Also in the <code>[ion]</code> section, set the address of your Bitcoin node in the <code>bitcoin_connection_string</code> parameter. If Bitcoin is running locally, set this to localhost and choose the correct port number for the particular Bitcoin network in use (see the example below).</li> <li>Also in the <code>[ion]</code> section, set the <code>bitcoin_rpc_username</code> and <code>bitcoin_rpc_password</code> parameters that were chosen when you configured the Bitcoin CLI.</li> <li>If you know the root event time for your DID network, add it in the <code>[cli]</code> section to the <code>root_event_time</code> parameter value. This must be an integer in Unix time format.</li> </ul> <p>After completing the above steps, the <code>trustchain_config.toml</code> file should look similar to the following example (choose the correct tab for your Bitcoin network configuration):</p> MainnetTestnet4Testnet3 (Deprecated) <pre><code>[ion]\nmongo_connection_string = \"mongodb://localhost:27017/\"\nmongo_database_ion_core = \"ion-mainnet-core\"\n\nbitcoin_connection_string = \"http://localhost:8332\"\nbitcoin_rpc_username = \"admin\"\nbitcoin_rpc_password = \"&lt;YOUR_BITCOIN_RPC_PASSWORD&gt;\"\n\n[cli]\nroot_event_time = 1697213008\nion_endpoint.host = \"127.0.0.1\"\nion_endpoint.port = 3000\n</code></pre> <pre><code>[ion]\nmongo_connection_string = \"mongodb://localhost:27017/\"\nmongo_database_ion_core = \"ion-testnet-core\"\n\nbitcoin_connection_string = \"http://localhost:48332\"\nbitcoin_rpc_username = \"admin\"\nbitcoin_rpc_password = \"&lt;YOUR_BITCOIN_RPC_PASSWORD&gt;\"\n\n[cli]\nroot_event_time = 1769521645\nion_endpoint.host = \"127.0.0.1\"\nion_endpoint.port = 3000\n</code></pre> <pre><code>[ion]\nmongo_connection_string = \"mongodb://localhost:27017/\"\nmongo_database_ion_core = \"ion-testnet-core\"\n\nbitcoin_connection_string = \"http://localhost:18332\"\nbitcoin_rpc_username = \"admin\"\nbitcoin_rpc_password = \"&lt;YOUR_BITCOIN_RPC_PASSWORD&gt;\"\n\n[cli]\nroot_event_time = 1697213008\nion_endpoint.host = \"127.0.0.1\"\nion_endpoint.port = 3000\n</code></pre> <p>Root event time</p> <p>The \"root event time\" refers to the exact time at which the root DID was published. It is imperative that this configuration parameter is entered correctly, because it identifies the root public key certificate.</p> <p>The value given in the above example is for illustration only.</p> <p>If you are not sure about the correct root event time for your network, or you are intending to create your own root DID, leave this parameter unset for now.</p> <p>In future versions of Trustchain, this Unix time parameter will be replaced by a calendar date, the \"root event date\", plus a short confirmation code (which is the format used in the Trustchain Mobile app).</p>"},{"location":"getting-started/#using-trustchain","title":"Using Trustchain","text":"<p>Trustchain is controlled via its command line interface (CLI). Supported operations include DID resolution, creation, attestation and verification. It can also be used to sign and verify digital credentials.</p> <p>Instructions on how to use the Trustchain CLI are provided on the Usage page.</p> <p>If you also want to be able to issue verifiable credentials to users of the Trustchain Mobile credential wallet app, check out this page for instructions on how to configure and run the built-in Trustchain HTTP server.</p> <p> </p>"},{"location":"glossary/","title":"Glossary","text":"<p>DID Decentralized Identifier (W3C standard). DIDs are string identifiers which can be resolved to obtain a DID document and document metadata.</p> <p>dDID see downstream DID</p> <p>downstream DID A DID whose document metadata contains a signature from an upstream entity attesting to the validity of the information contained in the corresponding DID document.</p> <p>DID document A file containing data pertaining to the DID subject, such as their public keys (or other verification material) and/or service endpoints.</p> <p>DID document metadata A file containing metadata pertaining to the corresponding DID document.</p> <p>DID subject The individual or legal entity to which a DID refers.</p> <p>DID controller An individual or legal entity who holds the update secret for a DID.</p> <p>upstream entity The subject of an upstream DID.</p> <p>upstream entity The subject of a downstream DID.</p> <p>update commitment</p> <p>update secret</p> <p>recovery commitment</p> <p>recovery secret</p> <p>root DID</p> <p>root event date</p> <p>root event time</p> <p>service</p> <p>service endpoint</p> <p> </p>"},{"location":"http-server/","title":"HTTP Server","text":"<p>Trustchain includes a built-in HTTP server that can be used to issue and verify digital credentials via an HTTP API. The server can also respond to requests made by the Trustchain Mobile app.</p> <p>Prerequisites</p> <p>To use the Trustchain HTTP server, first make sure that you have followed the installation and configuration instructions on the Getting Started page.</p> <p>Your ION node will also need to be up and running, either locally or on a remote machine to which you are connected via SSH and with port forwarding. Instructions for restarting ION, and setting up port forwarding, can be found here.</p>"},{"location":"http-server/#installation","title":"Installation","text":"<p>To install the Trustchain HTTP server, run: <pre><code>cargo install --path \"$TRUSTCHAIN_REPO\"/crates/trustchain-http\n</code></pre></p>"},{"location":"http-server/#configuration","title":"Configuration","text":"<p>Before starting the HTTP server some configuation parameters will need to be set. Execute the following command to open the Trustchain configuration file <code>trustchain_config.toml</code> for editing: <pre><code>nano $TRUSTCHAIN_CONFIG\n</code></pre></p> <p>Under the section headed <code>[http]</code>, add or edit the following configuration parameters:</p> <ul> <li>Set the <code>root_event_time</code> parameter to the integer root DID timestamp for your network (in Unix Time).</li> <li>Set the <code>host_display</code> parameter to the fully qualified domain name of your Trustchain HTTP server.</li> <li>Set the <code>host</code> parameter to the host address for the server. If you want the server to be accessible only on a local network, set this to <code>\"127.0.0.1\"</code> (localhost). If you want the server to be accessible from the Internet, set it to <code>\"0.0.0.0\"</code>. In this case, ensure both your router and server are protected by a properly configured firewall.</li> <li>Set the <code>port</code> parameter to the port number on which your server will listen for HTTP requests.</li> <li>Set the <code>https</code> parameter to either <code>true</code> or <code>false</code>, depending on whether your server will use TLS for encrypted communications.</li> <li>If <code>https</code> is set to <code>true</code>, set the  <code>https_path</code> parameter to the directory containing the certificate and key necessary for accepting HTTPS connections. See the section on HTTPS configuration for more details.</li> <li>Set the <code>ion_host</code> parameter to the host name of your ION instance. If ION is running on the local machine, set this to the loopback address <code>\"127.0.0.1\"</code>.</li> <li>Set the <code>ion_port</code> parameter to the port number of your ION instance. By default, ION listens on port <code>3000</code>.</li> <li>If you intend to use your server for credential verification and/or for dDID attestation (via the Trustchain challenge-response protocol), and you already have your own DID for this purpose, set it as the <code>server_did</code> parameter. If the server is only intended to respond to requests from the Trustchain Mobile app, e.g. for issuing verifiable credentials, this parameter is not required and can be omitted.</li> </ul> <p>Example HTTP server configuration</p> <p>After completing the above steps, the <code>[http]</code> section of <code>trustchain_config.toml</code> should look similar to the following example:</p> <pre><code>[http]\nroot_event_time = 1769521645\nhost_display = \"&lt;YOUR_SERVER_HOSTNAME&gt;\"\nport = 443\nhttps = true\nhttps_path = \"~/.trustchain/http/self_signed_certs\"\nhost = \"0.0.0.0\"\nion_host = \"127.0.0.1\"\nion_port = 3000\nserver_did = \"&lt;YOUR_SERVER_DID&gt;\"\n</code></pre>"},{"location":"http-server/#network-configuration","title":"Network configuration","text":"<p>To make your Trustchain HTTP server reachable from the public Internet you will need to configure your local network to allow connections to the port given in the <code>trustchain_config.toml</code> file, and to route them to your Trustchain node.</p> <p>If your Trustchain node is running on a virtual machine (VM) in the cloud, navigate to your cloud provider's web portal and open the network settings page for the VM. Then create an \"inbound port rule\" to allow incoming traffic to the relevant port.</p> <p>If your node is running on a computer in your local network, the network configuration steps are as follows:</p> <ul> <li>On your router, configure the firewall to allow connections to the port configured for the Trustchain server, and configure port forwarding (for the same port) to the IP address of your Trustchain node on the local network. To enable this, you may want to assign a static local IP address to your Trustchain node.</li> <li>If there is a firewall running on your Trustchain node, ensure it is configured to allow inbound connections to the relevant port.</li> </ul>"},{"location":"http-server/#https-configuration","title":"HTTPS configuration","text":"<p>It is strongly advisable to configure your Trustchain HTTP server to use TLS (Transport Layer Security) for encrypted communictions via HTTPS. This is done by setting the <code>https</code> config parameter to <code>true</code> and the <code>port</code> parameter to <code>443</code>, which is the default HTTPS port number.</p> <p>HTTPS is required to support Trustchain Mobile</p> <p>The Trustchain HTTP server is designed to handle requests from the Trustchain Mobile app, for operations such as the issuance and verification of Verifiable Credentials.</p> <p>If you intend to use the HTTP server for this purpose, it is essential that you configure it with HTTPS support. The Trustchain Mobile app will refuse to connect to a server that does not have a valid TLS certificate.</p> <p>To support HTTPS, you will need a TLS certificate and associated cryptographic keys.</p> <p>If you do not already have a TLS certificate, you can obtain one by using a free and open source service called Certbot. Certbot is a software tool for automatically generating Let's Encrypt certificates for web servers to enable HTTPS, which is precisely what is needed here.</p> <p>Follow the steps in the Certbot setup instructions to generate a TLS certificate.</p> <p>At the end of Step 6, you should see output similar to the following: <pre><code>Successfully received certificate.\nCertificate is saved at: /etc/letsencrypt/live/trustchain.example.com/fullchain.pem\nKey is saved at:         /etc/letsencrypt/live/trustchain.example.com/privkey.pem\nThis certificate expires on 2024-02-25.\nThese files will be updated when the certificate renews.\nCertbot has set up a scheduled task to automatically renew this certificate in the background.\n</code></pre></p> <p>Step 7 of the Certbot instructions requires you to install your new TLS certificate. To do this:</p> <ul> <li>make a new directory to store the certificate: <pre><code>mkdir -p \"$TRUSTCHAIN_DATA\"/http/self_signed_certs\n</code></pre></li> <li>copy the certificate file <code>fullchain.pem</code> and the key file <code>privkey.pem</code> from the locations given in the output from Step 6 (above), to the new directory, e.g.: <pre><code>sudo cp /etc/letsencrypt/live/trustchain.example.com/fullchain.pem \"$TRUSTCHAIN_DATA\"/http/self_signed_certs\nsudo cp /etc/letsencrypt/live/trustchain.example.com/privkey.pem \"$TRUSTCHAIN_DATA\"/http/self_signed_certs\n</code></pre></li> <li>change the ownership of those files so they are owned by the user and group that will run the Trustchain server (replace <code>&lt;USER&gt;</code> and <code>&lt;GROUP&gt;</code> in the following commands): <pre><code>sudo chown &lt;USER&gt;:&lt;GROUP&gt; \"$TRUSTCHAIN_DATA\"/http/self_signed_certs/fullchain.pem\nsudo chown &lt;USER&gt;:&lt;GROUP&gt; \"$TRUSTCHAIN_DATA\"/http/self_signed_certs/privkey.pem\n</code></pre></li> <li>create symbolic links to the certificate and key files: <pre><code>ln -s \"$TRUSTCHAIN_DATA\"/http/self_signed_certs/fullchain.pem \"$TRUSTCHAIN_DATA\"/http/self_signed_certs/cert.pem\nln -s \"$TRUSTCHAIN_DATA\"/http/self_signed_certs/privkey.pem \"$TRUSTCHAIN_DATA\"/http/self_signed_certs/key.pem\n</code></pre></li> </ul> <p>Running the Trustchain HTTP server on port 443</p> <p>By default, elevated privileges are required when binding a process to port 443. Therefore, if you have configured the HTTP server to listen on port 443, you will need to run the following command (once) to allow a non-root user to start the server: <pre><code>sudo setcap CAP_NET_BIND_SERVICE=+eip $HOME/.cargo/bin/trustchain-http\n</code></pre></p>"},{"location":"http-server/#running-the-http-server","title":"Running the HTTP server","text":"<p>Open a new Terminal window and invoke the Trustchain HTTP server with the following command: <pre><code>trustchain-http\n</code></pre></p> <p>The server will listen on the port specified in the <code>trustchain_config.toml</code> file. Server log messages will be printed to this terminal window, so you will see a new message whenever the server responds to a request.</p> <p> </p>"},{"location":"ion/","title":"ION","text":"<p>The Identity Overlay Network (ION) is an open source DID method implementation developed by the Decentralized Identity Foundation.</p> <p>In other words, ION is a software tool that can be used to perform DID operations, such as creating and publishing new DIDs and DID documents, and resolving existing ones. It does this by reading and writing data to the Bitcoin blockchain and to the IPFS distributed file system. As such, every ION instance is a node on these two peer-to-peer networks.</p> <p>Trustchain delegates the execution of DID operations to an ION node. Therefore to use Trustchain you must first install and run ION, either on the same machine or a connected one.</p> <p>ION resource requirements</p> <p>An ION installation includes a full node on the Bitcoin network, which must download and store the entire Bitcoin blockchain. This is a large amount of data that typically takes several hours, or even days, to download.</p> <p>The recommended system requirements for an ION installation are:</p> <ul> <li>6GB of RAM</li> <li>1.5TB of storage (or 100GB for Testnet4).</li> </ul> <p>Note, however, that Trustchain makes no assumptions about the trustworthiness of the ION system and the Trustchain security model does not rely on the correct functioning of the ION software. Trustchain independently verifies all of the data it receives from ION, so a faulty or compromised ION node would not represent a security vulnerability in Trustchain (although it could cause a loss of service).</p> <p>This page explains how to install and run ION.</p>"},{"location":"ion/#preliminaries","title":"Preliminaries","text":"<p>Before beginning the installation, a few decisions must be made that will determine exactly what steps should be taken.</p>"},{"location":"ion/#docker-container-vs-full-installation","title":"Docker Container vs. Full Installation","text":"<p>The simplest way to run ION is using Docker, and it can be a useful way to experiment with the system before performing a full installation. However, this method provides a read-only ION node. This means that it provides access to existing DIDs, but cannot be used to create and publish new ones.</p> <p>If you would like to be able to use Trustchain to create and publish your own DIDs, follow the full installation instructions below (and ignore the ION with Docker section).</p> <p>If you want to run ION using Docker, you can skip most of this page and just follow the instructions in the ION with Docker section.</p>"},{"location":"ion/#bitcoin-mainnet-vs-testnet","title":"Bitcoin Mainnet vs. Testnet","text":"<p>The Bitcoin client wrapped inside an ION node can be configured either for Mainnet (the main Bitcoin network) or Testnet (an alternative blockchain designed for testing and software development).</p> <p>Mainnet should be used for a production deployment of Trustchain because DID operations published on the Bitcoin blockchain have extremely strong immutability, persistence and discoverability properties. When testing Trustchain, however, it is sensible to configure the ION Bitcoin client for Testnet, since coins on the test network have no monetary value and therefore \"test\" DID operations can be executed at zero cost.</p> <p>The current iteration of Bitcoin's test network is Testnet4, which since May 2024 has replaced the (now deprecated) Testnet3. It is possible to run ION on either of these networks, but Testnet4 is strongly recommended over Testnet3.</p> <p>Testnet coins can be requested from a Testnet \"faucet\", such as this one for Testnet4 or this one for Testnet3.</p> <p>In this guide, commands and configuration settings may depend on which network is in use. In those cases, choose the appropriate tab for your setup: Mainnet, Testnet4 or Testnet3 (Deprecated).</p>"},{"location":"ion/#local-vs-remote-installation","title":"Local vs. Remote Installation","text":"<p>You can install ION on your local machine or a remote one, e.g. a virtual machine in the Cloud. If you are using a remote machine, connect to it using SSH and follow the instructions below.</p> <p>Once installed, follow the port forwarding instructions in the SSH config section to produce a setup that is indistinguishable from running an ION node locally.</p>"},{"location":"ion/#ion-installation-guide","title":"ION Installation Guide","text":"<p>These instructions are based on the official ION Install Guide but contain additional details, several minor corrections and a workaround to support recent versions of Bitcoin Core.</p> <p>Both Linux and macOS are supported and tested. For Linux, our instructions assume a Debian-based distribution, such as Ubuntu. Some minor changes will be needed for other distributions. Instructions for installing on Windows are given in the official ION guide.</p> <p>In all cases, administrator privileges are required.</p>"},{"location":"ion/#prerequisites","title":"Prerequisites","text":"<p>Create the <code>SHELL_CONFIG</code> environment variable</p> <p>Before continuing, make sure you have created the <code>SHELL_CONFIG</code> environment variable by following the instructions on the Getting Started page.</p> <p>Run the following commands to set up your environment.</p> LinuxmacOS <p>Update the package lists on your machine and install essential build tools: <pre><code>sudo apt update &amp;&amp; sudo apt install build-essential\n</code></pre> Install Git: <pre><code>sudo apt install git\n</code></pre> Install Node.js: <pre><code>sudo apt install nodejs\n</code></pre> and the Node package manager: <pre><code>sudo apt install npm\n</code></pre></p> <p>Install Xcode command line tools: <pre><code>xcode-select --install\n</code></pre> Install the Homebrew package manager: <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> Install Node.js via the download page or with this command: <pre><code>brew install node\n</code></pre></p>"},{"location":"ion/#install-ipfs","title":"Install IPFS","text":"<p>IPFS is the InterPlanetary File System, a peer-to-peer protocol and network used by ION for storing and sharing data.</p> LinuxmacOS <p>Follow the official IPFS installation instructions for Linux.</p> <p>Install IPFS: <pre><code>brew install ipfs\n</code></pre></p> <p>Then initialise your IPFS node: <pre><code>ipfs init\n</code></pre> To check the installation was successful, open a new Terminal window and start the IPFS daemon: <pre><code>ipfs daemon\n</code></pre> Then (back in the original Terminal window) run: <pre><code>ipfs cat /ipfs/QmQPeNsJPyVWPFDVHb77w8G42Fvo15z4bG2X8D2GhfbSXc/readme\n</code></pre> which should output a welcome message.</p>"},{"location":"ion/#install-mongodb","title":"Install MongoDB","text":"LinuxmacOS <p>Instructions for installing MongoDB on Linux are available on the MongoDB website.</p> <p>Following these instructions: <pre><code>brew tap mongodb/brew\n</code></pre> then: <pre><code>brew install mongodb-community\n</code></pre></p>"},{"location":"ion/#install-bitcoin-core","title":"Install Bitcoin Core","text":"<p>Trustchain has been tested with Bitcoin Core v28.0 and therefore the instructions below assume that version. Other versions of Bitcoin Core are available and can be used, but will require some minor changes to the commands in the following steps.</p> <p>Testnet4 requires Bitcoin Core v28.0 or above</p> <p>If you are intending to run ION on Testnet4 you must install Bitcoin Core v28.0 or above, as this is the earliest version that supports the new test network.</p> LinuxmacOS <p>Begin by downloading the Bitcoin Core release for your system:</p> <ul> <li>Download link for Linux with x86-64 processor.</li> <li>Download link for Linux with ARM processor.</li> </ul> <p>Verify the download by comparing the published hash with the result of this command: <pre><code>shasum -a 256 ~/Downloads/bitcoin-28.0-*.tar.gz\n</code></pre></p> <p>Unzip the archive: <pre><code>(cd ~/Downloads &amp;&amp; tar xvzf bitcoin-28.0-*.tar.gz)\n</code></pre> and install Bitcoin Core: <pre><code>sudo install -m 0755 -t /usr/local/bin ~/Downloads/bitcoin-28.0/bin/*\n</code></pre> The installation includes an executable file named <code>bitcoind</code> which we will run to start Bitcoin Core.</p> <p>Begin by downloading the Bitcoin Core release for your system:</p> <ul> <li>Download link for Mac with x86-64 processor.</li> <li>Download link for Mac with Apple M-series processor.</li> </ul> <p>Verify the download by comparing the published hash with the result of this command: <pre><code>shasum -a 256 ~/Downloads/bitcoin-28.0-*.tar.gz\n</code></pre></p> <p>Unzip the archive: <pre><code>(cd ~/Downloads &amp;&amp; tar xvzf bitcoin-28.0-*.tar.gz)\n</code></pre> and move the contents to the <code>/Applications</code> folder: <pre><code>mv ~/Downloads/bitcoin-28.0 /Applications\n</code></pre> The download contains an executable file named <code>bitcoind</code> which we will run to start Bitcoin Core.</p> <p>Sign the Bitcoin Core executable files</p> <p>Newer macOS systems will refuse to run an executable file unless it is signed. Run the following command to check whether this is a requirement on your machine: <pre><code>codesign -d -vvv --entitlements :- /Applications/bitcoin-28.0/bin/bitcoind\n</code></pre> If you see the message \"code object is not signed at all\", you will need to create a self-signed certificate for the executable file. Do this by running: <pre><code>codesign -s - /Applications/bitcoin-28.0/bin/bitcoind\n</code></pre> And do the same for the Bitcoin CLI executable: <pre><code>codesign -s - /Applications/bitcoin-28.0/bin/bitcoin-cli\n</code></pre></p>"},{"location":"ion/#configure-bitcoin-core","title":"Configure Bitcoin Core","text":"<p>We shall need to specify a folder to store the Bitcoin blockchain data.</p> <p>Bitcoin data storage requirements</p> <p>The Bitcoin data folder will store the entire Bitcoin blockchain, which is &gt;800GB for Mainnet and &gt;15GB for Testnet4.</p> <p>For convenience, we create an environment variable for the Bitcoin data folder.</p> <p>Create the <code>BITCOIN_DATA</code> environment variable</p> <p>Our convention is to use the folder <code>~/.bitcoin</code> for Bitcoin Core data. If you want to use a different folder, just change the path in the following command: <pre><code>echo \"export BITCOIN_DATA=~/.bitcoin\" &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre></p> <p>Having defined the <code>BITCOIN_DATA</code> environment variable, use it to create the data folder itself: <pre><code>mkdir $BITCOIN_DATA\n</code></pre></p> MainnetTestnet4Testnet3 (Deprecated) <p>Bitcoin configuration parameters will be stored in a file named <code>bitcoin.conf</code> inside the <code>$BITCOIN_DATA</code> folder. The following command creates that file with the required parameters and user permissions: <pre><code>printf \"server=1\\ndaemon=1\\ntxindex=1\\nblocksxor=0\\ndatadir=$BITCOIN_DATA\\ndeprecatedrpc=create_bdb\\ndeprecatedrpc=warnings\\n\" &gt; $BITCOIN_DATA/bitcoin.conf &amp;&amp; chmod 640 $BITCOIN_DATA/bitcoin.conf\n</code></pre></p> <p>To confirm these changes were made correctly, check the first three lines in the <code>bitcoin.conf</code> file by running: <pre><code>head -n 7 $BITCOIN_DATA/bitcoin.conf\n</code></pre> You should see lines like these printed to the Terminal: <pre><code>server=1\ndaemon=1\ntxindex=1\nblocksxor=0\ndatadir=&lt;YOUR_BITCOIN_DATA_DIRECTORY&gt;\ndeprecatedrpc=create_bdb\ndeprecatedrpc=warnings\n</code></pre></p> <p>Bitcoin configuration parameters will be stored in a file named <code>bitcoin.conf</code> inside the <code>$BITCOIN_DATA</code> folder. The following command creates that file with the required parameters and user permissions: <pre><code>printf \"testnet4=1\\nserver=1\\ndaemon=1\\ntxindex=1\\nblocksxor=0\\ndatadir=$BITCOIN_DATA\\ndeprecatedrpc=create_bdb\\ndeprecatedrpc=warnings\\n\" &gt; $BITCOIN_DATA/bitcoin.conf &amp;&amp; chmod 640 $BITCOIN_DATA/bitcoin.conf\n</code></pre></p> <p>To confirm these changes were made correctly, check the first three lines in the <code>bitcoin.conf</code> file by running: <pre><code>head -n 8 $BITCOIN_DATA/bitcoin.conf\n</code></pre> You should see lines like these printed to the Terminal: <pre><code>testnet4=1\nserver=1\ndaemon=1\ntxindex=1\nblocksxor=0\ndatadir=&lt;YOUR_BITCOIN_DATA_DIRECTORY&gt;\ndeprecatedrpc=create_bdb\ndeprecatedrpc=warnings\n</code></pre></p> <p>Bitcoin configuration parameters will be stored in a file named <code>bitcoin.conf</code> inside the <code>$BITCOIN_DATA</code> folder. The following command creates that file with the required parameters and user permissions: <pre><code>printf \"testnet=1\\nserver=1\\ndaemon=1\\ntxindex=1\\nblocksxor=0\\ndatadir=$BITCOIN_DATA\\ndeprecatedrpc=create_bdb\\ndeprecatedrpc=warnings\\n\" &gt; $BITCOIN_DATA/bitcoin.conf &amp;&amp; chmod 640 $BITCOIN_DATA/bitcoin.conf\n</code></pre></p> <p>To confirm these changes were made correctly, check the first three lines in the <code>bitcoin.conf</code> file by running: <pre><code>head -n 8 $BITCOIN_DATA/bitcoin.conf\n</code></pre> You should see lines like these printed to the Terminal: <pre><code>testnet=1\nserver=1\ndaemon=1\ntxindex=1\nblocksxor=0\ndatadir=&lt;YOUR_BITCOIN_DATA_DIRECTORY&gt;\ndeprecatedrpc=create_bdb\ndeprecatedrpc=warnings\n</code></pre></p> <p>Configuration in older versions of Bitcoin Core</p> <p>If you are running an older version of Bitcoin Core, you may need to omit the <code>deprecatedrpc</code> parameters from your configuration file:</p> <ul> <li>the settings <code>blocksxor=0</code> and <code>deprecatedrpc=warnings</code> were introduced in Bitcoin Core v28.0, so they must be omitted if you are running an earlier version.</li> <li>the setting <code>deprecatedrpc=create_bdb</code> was introduced in Bitcoin Core v26.0, so it must be omitted if you are running an earlier version.</li> </ul> <p>Note: Do not use the <code>~</code> shorthand in the <code>datadir</code> parameter</p> <p>The directory path in the <code>datadir</code> parameter must not contain the <code>~</code> character as a shorthand for the user's home directory.</p> <p>The example given in the official ION install guide does use this shorthand, which causes an error, so beware of this issue if you are following that guide and/or editing the <code>bitcoin.conf</code> file manually.</p>"},{"location":"ion/#configure-bitcoin-cli","title":"Configure Bitcoin CLI","text":"<p>When your Bitcoin Core node is up and running, you will want to be able to communicate with it. Bitcoin Core provides a command line interface (CLI) for this purpose.</p> <p>Run the following command to create an alias, making to easy to access the CLI:</p> LinuxmacOS <pre><code>echo 'alias bitcoin-cli=\"/usr/local/bin/bitcoin-cli -conf=$BITCOIN_DATA/bitcoin.conf\"' &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre> <pre><code>echo 'alias bitcoin-cli=\"/Applications/bitcoin-28.0/bin/bitcoin-cli -conf=$BITCOIN_DATA/bitcoin.conf\"' &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre> <p>Bitcoin RPC username and password</p> <p>Before you can make use of the CLI you will need to add a username and password to the Bitcoin configuration file. These same parameters will also be used for authentication when ION interacts with Bitcoin Core. In both cases, the interaction is possible because Bitcoin Core provides access via a Remote Procedure Call (RPC) interface.</p> <p>We shall use <code>admin</code> for the RPC username. To set up the RPC password, copy and paste the following command into the Terminal and then change <code>&lt;password&gt;</code> to something of your choice before hitting the Enter key: <pre><code>RPC_PASSWORD=\"&lt;password&gt;\"\n</code></pre> Now run the following command to add the username and password to the <code>bitcoin.conf</code> file:</p> LinuxmacOS <pre><code>sed -i \"1s|^|rpcuser=admin\\nrpcpassword=$RPC_PASSWORD\\n|\" $BITCOIN_DATA/bitcoin.conf\n</code></pre> <pre><code>sed -i '' $'1s|^|rpcuser=admin\\\\\\nrpcpassword='\"$RPC_PASSWORD\"$'\\\\\\n|' $BITCOIN_DATA/bitcoin.conf\n</code></pre> <p>To confirm these changes were made correctly, check the first two lines in the <code>bitcoin.conf</code> file by running: <pre><code>head -n 2 $BITCOIN_DATA/bitcoin.conf\n</code></pre> You should see these lines printed to the Terminal (with your chosen password): <pre><code>rpcuser=admin\nrpcpassword=&lt;password&gt;\n</code></pre></p>"},{"location":"ion/#start-bitcoin-core","title":"Start Bitcoin Core","text":"<p>Before we start Bitcoin Core, we need to make sure it can find the correct configuration file that was created above. To make this convenient, let's create an alias in our <code>SHELL_CONFIG</code> file:</p> LinuxmacOS <pre><code>echo 'alias bitcoind=\"/usr/local/bin/bitcoind -conf=$BITCOIN_DATA/bitcoin.conf\"' &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre> <p>Now, use the following simple command to start Bitcoin Core: <pre><code>bitcoind\n</code></pre></p> <pre><code>echo 'alias bitcoind=\"/Applications/bitcoin-28.0/bin/bitcoind -conf=$BITCOIN_DATA/bitcoin.conf\"' &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre> <p>Now, use the following simple command to start Bitcoin Core: <pre><code>bitcoind\n</code></pre> The first time your run this command, you will see the following pop-up message:</p> <p></p> <p>You need to tell macOS that this is not malicious software. To do this, open the \"Security &amp; Privacy\" settings in System Preferences, choose the \"General\" tab, and click the button on the right-hand side that says \"Allow Anyway\":</p> <p></p> <p>Now re-run the command to start Bitcoin Core: <pre><code>bitcoind\n</code></pre> Another pop-up message will appear, similar to the first one, but this time there will be an option to allow the program to run by clicking the \"Open\" button.</p> <p>You should now see the message \"Bitcoin Core starting\" in the Terminal.</p> <p>Bitcoin synchronisation</p> <p>When Bitcoin Core starts for the first time, it will begin synchronising with the rest of the Bitcoin network. This means downloading all of the blocks in the Bitcoin blockchain, which is a large data structure containing every Bitcoion transaction that has ever been processed.</p> <p>The synchronisation process on Mainnet may take several hours, or even days, to complete. You can continue with the installation steps below while it is in progress, but you will not be able to use Trustchain until your Bitcoin node has finished synchronising.</p> <p>Fortunately, the synchronisation process on Testnet4 is much quicker, as only ~15GB of data must be downloaded.</p> <p>Whenever Bitcoin Core is running, you can invoke the Bitcoin CLI with commands beginning <code>bitcoin-cli</code>. A full list of commands available via the Bitcoin CLI can be found here.</p> <p>One useful example is the following <code>-getinfo</code> command. It reports information about the state of your Bitcoin node, including whether it is fully synchronised: <pre><code>bitcoin-cli -getinfo\n</code></pre></p> <p>Create a Bitcoin wallet for ION</p> <p>Before using ION you must create a Bitcoin wallet by running the following CLI command: <pre><code>bitcoin-cli -named createwallet wallet_name=\"sidetreeDefaultWallet\" descriptors=false\n</code></pre> Expected output: <pre><code>{\n  \"name\": \"sidetreeDefaultWallet\",\n  \"warnings\": [\n    \"Wallet created successfully. The legacy wallet type is being deprecated and support for creating and opening legacy wallets will be removed in the future.\"\n  ]\n}\n</code></pre> Note that we have chosen to create a \"legacy\" Bitcoin wallet, for compatibility with ION.</p>"},{"location":"ion/#configure-ion","title":"Configure ION","text":"<p>Choose a directory in which you want to store the ION software and change to that directory using the command <code>cd &lt;DIRECTORY_NAME&gt;</code>. For instance, to change to your home directory run the <code>cd</code> command without any arguments: <pre><code>cd\n</code></pre> Now clone the ION code repository from GitHub: <pre><code>git clone https://github.com/decentralized-identity/ion.git\n</code></pre> and change into the newly-created <code>ion</code> subfolder: <pre><code>cd ion\n</code></pre></p> <p>Create the <code>ION_REPO</code> environment variable</p> <p>Since we will need to refer to this folder in future, let's create an environment variable containing its file path: <pre><code>echo \"export ION_REPO=\" $(pwd) | sed 's/= /=/g' &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre></p> <p>We will need a folder for storing ION configuration files. For convenience, we'll also create an environment variable for that folder.</p> <p>Create the <code>ION_CONFIG</code> environment variables</p> <p>Our convention is to use the folder <code>~/.ion</code> for ION configuration files. If you want to use a different folder, just change the path in the following command: <pre><code>echo \"export ION_CONFIG=~/.ion\" &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre></p> <p>We also need environment variables for each of the four files that will be stored in the ION config folder, so ION can find them when it starts up. The following command creates all four environment variables:</p> MainnetTestnet4Testnet3 (Deprecated) <pre><code>printf \"export ION_BITCOIN_CONFIG_FILE_PATH=$ION_CONFIG/mainnet-bitcoin-config.json\\nexport ION_BITCOIN_VERSIONING_CONFIG_FILE_PATH=$ION_CONFIG/mainnet-bitcoin-versioning.json\\nexport ION_CORE_CONFIG_FILE_PATH=$ION_CONFIG/mainnet-core-config.json\\nexport ION_CORE_VERSIONING_CONFIG_FILE_PATH=$ION_CONFIG/mainnet-core-versioning.json\" &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre> <pre><code>printf \"export ION_BITCOIN_CONFIG_FILE_PATH=$ION_CONFIG/testnet-bitcoin-config.json\\nexport ION_BITCOIN_VERSIONING_CONFIG_FILE_PATH=$ION_CONFIG/testnet-bitcoin-versioning.json\\nexport ION_CORE_CONFIG_FILE_PATH=$ION_CONFIG/testnet-core-config.json\\nexport ION_CORE_VERSIONING_CONFIG_FILE_PATH=$ION_CONFIG/testnet-core-versioning.json\" &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre> <pre><code>printf \"export ION_BITCOIN_CONFIG_FILE_PATH=$ION_CONFIG/testnet-bitcoin-config.json\\nexport ION_BITCOIN_VERSIONING_CONFIG_FILE_PATH=$ION_CONFIG/testnet-bitcoin-versioning.json\\nexport ION_CORE_CONFIG_FILE_PATH=$ION_CONFIG/testnet-core-config.json\\nexport ION_CORE_VERSIONING_CONFIG_FILE_PATH=$ION_CONFIG/testnet-core-versioning.json\" &gt;&gt; $SHELL_CONFIG; source $SHELL_CONFIG\n</code></pre> <p>Having defined the <code>ION_CONFIG</code> environment variable (above), use it to create the folder itself: <pre><code>mkdir $ION_CONFIG\n</code></pre></p> <p>Next, copy the template ION configuration files to your <code>ION_CONFIG</code> directory:</p> MainnetTestnet4Testnet3 (Deprecated) <pre><code>cp $ION_REPO/config/mainnet-bitcoin-config.json $ION_REPO/config/mainnet-bitcoin-versioning.json $ION_REPO/config/mainnet-core-config.json $ION_REPO/config/mainnet-core-versioning.json $ION_CONFIG\n</code></pre> <pre><code>cp $ION_REPO/config/testnet-bitcoin-config.json $ION_REPO/config/testnet-bitcoin-versioning.json $ION_REPO/config/testnet-core-config.json $ION_REPO/config/testnet-core-versioning.json $ION_CONFIG\n</code></pre> <pre><code>cp $ION_REPO/config/testnet-bitcoin-config.json $ION_REPO/config/testnet-bitcoin-versioning.json $ION_REPO/config/testnet-core-config.json $ION_REPO/config/testnet-core-versioning.json $ION_CONFIG\n</code></pre> <p>and set appropriate user permissions: <pre><code>chmod 640 $ION_BITCOIN_CONFIG_FILE_PATH $ION_BITCOIN_VERSIONING_CONFIG_FILE_PATH $ION_CORE_CONFIG_FILE_PATH $ION_CORE_VERSIONING_CONFIG_FILE_PATH\n</code></pre></p> <p>Having made copies of the template configuration files, we now edit some of their parameters to match our Bitcoin Core configuration.</p> MainnetTestnet4Testnet3 (Deprecated) <p>Set the <code>bitcoinDataDirectory</code> parameter (skip this step if your <code>BITCOIN_DATA</code> directory is on a network drive):</p> LinuxmacOS <pre><code>sed -i 's|\"bitcoinDataDirectory\": \".*\"|\"bitcoinDataDirectory\": \"'$BITCOIN_DATA'\"|' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <pre><code>sed -i '' 's|\"bitcoinDataDirectory\": \".*\"|\"bitcoinDataDirectory\": \"'$BITCOIN_DATA'\"|' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <p>Set the <code>bitcoinDataDirectory</code> parameter in the ION Bitcoin config file:</p> LinuxmacOS <pre><code>sed -i 's|\"bitcoinDataDirectory\": \".*\"|\"bitcoinDataDirectory\": \"'$BITCOIN_DATA'/testnet4\"|' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <pre><code>sed -i '' 's|\"bitcoinDataDirectory\": \".*\"|\"bitcoinDataDirectory\": \"'$BITCOIN_DATA'/testnet4\"|' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <p>Next, for Testnet4 only, set two further parameters in the same file. First the <code>bitcoinPeerUri</code> parameter:</p> LinuxmacOS <pre><code>sed -i 's|\"bitcoinPeerUri\": \"http://localhost:18332\"|\"bitcoinPeerUri\": \"http://localhost:48332\"|' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <pre><code>sed -i '' 's|\"bitcoinPeerUri\": \"http://localhost:18332\"|\"bitcoinPeerUri\": \"http://localhost:48332\"|' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <p>and second, the <code>genesisBlockNumber</code> parameter:</p> LinuxmacOS <pre><code>sed -i 's|\"genesisBlockNumber\": .*,|\"genesisBlockNumber\": 2000,|' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <pre><code>sed -i '' 's|\"genesisBlockNumber\": .*,|\"genesisBlockNumber\": 2000,|' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <p>Also for Testnet4 only, set the <code>startingBlockchainTime</code> parameter in the ION Bitcoin versioning config file:</p> LinuxmacOS <pre><code>sed -i 's|\"startingBlockchainTime\": .*,|\"startingBlockchainTime\": 2000,|' $ION_BITCOIN_VERSIONING_CONFIG_FILE_PATH\n</code></pre> <pre><code>sed -i '' 's|\"startingBlockchainTime\": .*,|\"startingBlockchainTime\": 2000,|' $ION_BITCOIN_VERSIONING_CONFIG_FILE_PATH\n</code></pre> <p>and the same parameter in the ION Core versioning config file:</p> LinuxmacOS <pre><code>sed -i 's|\"startingBlockchainTime\": .*,|\"startingBlockchainTime\": 2000,|' $ION_CORE_VERSIONING_CONFIG_FILE_PATH\n</code></pre> <pre><code>sed -i '' 's|\"startingBlockchainTime\": .*,|\"startingBlockchainTime\": 2000,|' $ION_CORE_VERSIONING_CONFIG_FILE_PATH\n</code></pre> <p>Set the <code>bitcoinDataDirectory</code> parameter (skip this step if your <code>BITCOIN_DATA</code> directory is on a network drive):</p> LinuxmacOS <pre><code>sed -i 's|\"bitcoinDataDirectory\": \".*\"|\"bitcoinDataDirectory\": \"'$BITCOIN_DATA'/testnet3\"|' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <pre><code>sed -i '' 's|\"bitcoinDataDirectory\": \".*\"|\"bitcoinDataDirectory\": \"'$BITCOIN_DATA'/testnet3\"|' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <p> Next we shall set the <code>bitcoinRpcUsername</code> and <code>bitcoinRpcPassword</code> parameters. These must match the username and password chosen in the Bitcoin CLI section above.</p> <p>We chose <code>admin</code> for the RPC username. The following command sets this same value inside the ION Bitcoin config file:</p> LinuxmacOS <pre><code>sed -i 's|\"bitcoinRpcUsername\": \".*\"|\"bitcoinRpcUsername\": \"admin\"|' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <pre><code>sed -i '' 's|\"bitcoinRpcUsername\": \".*\"|\"bitcoinRpcUsername\": \"admin\"|' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <p>For the RPC password, copy and paste the following command into the Terminal and then change <code>&lt;password&gt;</code> to the same password you chose when setting up the Bitcoin CLI: <pre><code>RPC_PASSWORD=\"&lt;password&gt;\"\n</code></pre></p> <p>Then run this command to update the <code>bitcoinRpcPassword</code> parameter in the ION config file:</p> LinuxmacOS <pre><code>sed -i 's|\"bitcoinRpcPassword\": \".*\"|\"bitcoinRpcPassword\": \"'$RPC_PASSWORD'\"|g' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <pre><code>sed -i '' 's|\"bitcoinRpcPassword\": \".*\"|\"bitcoinRpcPassword\": \"'$RPC_PASSWORD'\"|g' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <p>The final configuration step is to set the <code>bitcoinWalletOrImportString</code> parameter.</p> MainnetTestnet4Testnet3 (Deprecated) <p>This must be a mainnet-compatible private key in wallet import format (WIF).</p> <p>If you do not intend to use Trustchain to write your own DID operations, you can use this tool to randomly generate a WIF string without any bitcoin.</p> <p>If you are intending to use Trustchain to write your own DID operations, this parameter must be populated with your private key in the appropriate format. To do this, first check that <code>sidetreeDefaultWallet</code> (that was created earlier) is loaded. You should see the following output when running this command: <pre><code>bitcoin-cli listwallets\n[\n  \"sidetreeDefaultWallet\"\n]\n</code></pre> Next create a wallet address with this command: <pre><code>bitcoin-cli getnewaddress\n</code></pre> This command will output a new address (a long string of characters).</p> <p>Now, to get the private key for this Bitcoin address, run the following command but with <code>&lt;address&gt;</code> replaced with the output from the previous step: <pre><code>bitcoin-cli dumpprivkey &lt;address&gt;\n</code></pre> Once again, the output will be a long string of characters. This is the WIF string to be used in the following command.</p> <p>Never share your Bitcoin private keys</p> <p>The output from the previous command is the Bitcoin private key corresponding to your wallet address. Anyone who has access to this private key can spend the bitcoins in that address, so you should be careful to keep it secret.</p> <p>In the following step we will copy the private key into an ION configuration file, to enable ION to execute the Bitcoin transactions necessary to create and update DIDs. The permissions on this configuration file have already been set (above) so that only the user and their group can read the file contents.</p> <p>Copy and paste this command into the Terminal and then change <code>&lt;wif&gt;</code> to your WIF string: <pre><code>WIF=\"&lt;wif&gt;\"\n</code></pre></p> <p>Then run this command to update the <code>bitcoinWalletOrImportString</code> parameter in the ION config file:</p> LinuxmacOS <pre><code>sed -i 's|\"bitcoinWalletOrImportString\": \".*\"|\"bitcoinWalletOrImportString\": \"'$WIF'\"|g' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <pre><code>sed -i '' 's|\"bitcoinWalletOrImportString\": \".*\"|\"bitcoinWalletOrImportString\": \"'$WIF'\"|g' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <p>On Testnet4, a key will be automatically generated when ION runs for the first time which can be used for the <code>bitcoinWalletOrImportString</code> parameter, so you don't need to do anything in this step.</p> <p>On Testnet3, a key will be automatically generated when ION runs for the first time which can be used for the <code>bitcoinWalletOrImportString</code> parameter, so you don't need to do anything in this step.</p> <p>Tip: Set the <code>requestMaxRetries</code> configuration parameter</p> <p>This step is optional but is strongly recommended because it may significantly speed up the synchronisation process which takes place when ION runs for the first time.</p> <p>When ION requests information from the local Bitcoin node it may have to retry several times before receiving a response. This is particularly common during its initial synchronisation, when many requests are made at high frequency.</p> <p>After several failed requests ION will stop trying and the synchronisation process will restart, forfeiting the progress already made. By default this will happen after only three failed attempts, but this can be increased by setting the <code>requestMaxRetries</code> config parameter.</p> <p>Run the following command to increase the maximum number of retry attempts:</p> LinuxmacOS <pre><code>N=$(grep -n '\\\"port\\\"' $ION_BITCOIN_CONFIG_FILE_PATH | cut -d':' -f1); sed -i \"$((N+1))\"'i\\'$'\\n''  \"requestMaxRetries\": 6,'$'\\n' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <pre><code>N=$(grep -n '\\\"port\\\"' $ION_BITCOIN_CONFIG_FILE_PATH | cut -d':' -f1); sed -i '' \"$((N+1))\"'i\\'$'\\n''  \"requestMaxRetries\": 6,'$'\\n' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre>"},{"location":"ion/#build-ion","title":"Build ION","text":"<p>Change directory into the ION repository: <pre><code>cd $ION_REPO\n</code></pre> Now install the ION dependencies: <pre><code>npm i\n</code></pre> make sure Typescript is installed: <pre><code>npm install typescript\n</code></pre> and then build the ION package: <pre><code>npm run build\n</code></pre></p> <p>Note: Rebuild ION whenever a configuration file is modified</p> <p>You must rerun the command <code>npm run build</code> if changes are made to the JSON configuration files in the <code>ION_CONFIG</code> folder.</p> Additional configuration steps required for Testnet4 <p>ION has built-in support for Bitcoin Mainnet and Testnet3, but not for Testnet4. To fix this, the following additional steps must be performed (after completing the ION build procedure) only if you are running on Testnet4.</p> <p>Run the following command to update your ION installation with the Testnet4 magic bytes, used to delimit messages on the Bitcoin network:</p> LinuxmacOS <pre><code>sed -i \"s/testnet: Buffer\\.from('0b110907', 'hex')/testnet: Buffer.from('1c163f28', 'hex')/\" $ION_REPO/node_modules/@decentralized-identity/sidetree/dist/lib/bitcoin/BitcoinRawDataParser.js\n</code></pre> <pre><code>sed -i '' \"s/testnet: Buffer\\.from('0b110907', 'hex')/testnet: Buffer.from('1c163f28', 'hex')/\" $ION_REPO/node_modules/@decentralized-identity/sidetree/dist/lib/bitcoin/BitcoinRawDataParser.js\n</code></pre> <p>Run this command to fix the way ION computes the Testnet4 block height:</p> LinuxmacOS <pre><code>sed -i 's/magicBytes\\.equals(BitcoinRawDataParser\\.magicBytes\\.regtest)/(magicBytes\\.equals(BitcoinRawDataParser\\.magicBytes\\.regtest) || (magicBytes\\.equals(BitcoinRawDataParser\\.magicBytes\\.testnet)))/' $ION_REPO/node_modules/@decentralized-identity/sidetree/dist/lib/bitcoin/BitcoinRawDataParser.js\n</code></pre> <pre><code>sed -i '' 's/magicBytes\\.equals(BitcoinRawDataParser\\.magicBytes\\.regtest)/(magicBytes\\.equals(BitcoinRawDataParser\\.magicBytes\\.regtest) || (magicBytes\\.equals(BitcoinRawDataParser\\.magicBytes\\.testnet)))/' $ION_REPO/node_modules/@decentralized-identity/sidetree/dist/lib/bitcoin/BitcoinRawDataParser.js\n</code></pre> <p>Finally, run the following command to avoid errors when performing fee estimation on Testnet4 (required for publishing DID operations from your ION node):</p> LinuxmacOS <pre><code>sed -i 's|1 // Number of confirmation targets|50 // Number of confirmation targets|' $ION_REPO/node_modules/@decentralized-identity/sidetree/dist/lib/bitcoin/BitcoinClient.js\n</code></pre> <pre><code>sed -i '' 's|1 // Number of confirmation targets|50 // Number of confirmation targets|' $ION_REPO/node_modules/@decentralized-identity/sidetree/dist/lib/bitcoin/BitcoinClient.js\n</code></pre>"},{"location":"ion/#test-ion","title":"Test ION","text":"<p>Before running ION for the first time, make sure that you have started IPFS, MongoDB and Bitcoin Core (by following the instructions above or using the command summary in the Running ION section). Also make sure that Bitcoin Core is fully synchronised by running: <pre><code>bitcoin-cli -getinfo\n</code></pre></p> <p>You should see output similar to the following. Bitcoin Core is synchronised if the number of <code>Blocks</code> is equal to the number of <code>Headers</code>:</p> MainnetTestnet4Testnet3 (Deprecated) <pre><code>Chain: main\nBlocks: 933111\nHeaders: 933111\nVerification progress: 99.9998%\nDifficulty: 146472570619930.8\n\nNetwork: in 0, out 10, total 10\nVersion: 280000\nTime offset (s): 0\nProxies: n/a\nMin tx relay fee rate (BTC/kvB): 0.00001000\n\nWallet: sidetreeDefaultWallet\nKeypool size: 1000\nTransaction fee rate (-paytxfee) (BTC/kvB): 0.00000000\n\nBalance: 0.00000000\n</code></pre> <p>In a new Terminal, start the ION Bitcoin microservice with: <pre><code>(cd $ION_REPO &amp;&amp; npm run bitcoin)\n</code></pre></p> <pre><code>Chain: testnet4\nBlocks: 119371\nHeaders: 119371\nVerification progress: 100.0000%\nDifficulty: 1\n\nNetwork: in 0, out 11, total 11\nVersion: 280000\nTime offset (s): 0\nProxies: n/a\nMin tx relay fee rate (BTC/kvB): 0.00001000\n\nWallet: sidetreeDefaultWallet\nKeypool size: 1000\nTransaction fee rate (-paytxfee) (BTC/kvB): 0.00000000\n\nBalance: 0.00000000\n</code></pre> <p>In a new Terminal, start the ION Bitcoin microservice with: <pre><code>(cd $ION_REPO &amp;&amp; npm run bitcoin)\n</code></pre></p> <p>When running this command for the first time, expect the error: <pre><code>Non-base58 character\nIs bitcoinWalletImportString valid? Consider using &lt;testnet&gt; key generated below:\n</code></pre> followed by a base58 string (another long string of characters). In this case, copy the base58 string and paste it into the following command in place of <code>&lt;wif&gt;</code>: <pre><code>WIF=\"&lt;wif&gt;\"\n</code></pre></p> <p>Then run this command to update the <code>bitcoinWalletOrImportString</code> parameter in the ION config file:</p> LinuxmacOS <pre><code>sed -i 's|\"bitcoinWalletOrImportString\": \".*\"|\"bitcoinWalletOrImportString\": \"'$WIF'\"|g' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <pre><code>sed -i '' 's|\"bitcoinWalletOrImportString\": \".*\"|\"bitcoinWalletOrImportString\": \"'$WIF'\"|g' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <p>Now repeat the attempt to start the ION Bitcoin microservice: <pre><code>(cd $ION_REPO &amp;&amp; npm run bitcoin)\n</code></pre></p> <pre><code>Chain: test\nBlocks: 4834624\nHeaders: 4834624\nVerification progress: 99.9999%\nDifficulty: 2154250.232295683\n\nNetwork: in 0, out 10, total 10\nVersion: 280000\nTime offset (s): 0\nProxies: n/a\nMin tx relay fee rate (BTC/kvB): 0.00001000\n\nWallet: sidetreeDefaultWallet\nKeypool size: 1000\nTransaction fee rate (-paytxfee) (BTC/kvB): 0.00000000\n\nBalance: 0.00000000\n</code></pre> <p>In a new Terminal, start the ION Bitcoin microservice with: <pre><code>(cd $ION_REPO &amp;&amp; npm run bitcoin)\n</code></pre></p> <p>When running this command for the first time, expect the error: <pre><code>Non-base58 character\nIs bitcoinWalletImportString valid? Consider using &lt;testnet&gt; key generated below:\n</code></pre> followed by a base58 string (another long string of characters). In this case, copy the base58 string and paste it into the following command in place of <code>&lt;wif&gt;</code>: <pre><code>WIF=\"&lt;wif&gt;\"\n</code></pre></p> <p>Then run this command to update the <code>bitcoinWalletOrImportString</code> parameter in the ION config file:</p> LinuxmacOS <pre><code>sed -i 's|\"bitcoinWalletOrImportString\": \".*\"|\"bitcoinWalletOrImportString\": \"'$WIF'\"|g' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <pre><code>sed -i '' 's|\"bitcoinWalletOrImportString\": \".*\"|\"bitcoinWalletOrImportString\": \"'$WIF'\"|g' $ION_BITCOIN_CONFIG_FILE_PATH\n</code></pre> <p>Now repeat the attempt to start the ION Bitcoin microservice: <pre><code>(cd $ION_REPO &amp;&amp; npm run bitcoin)\n</code></pre></p> <p>ION synchronisation</p> <p>When the ION Bitcoin microservice starts for the first time, it will begin scanning the Bitcoin blockchain for ION DID operations, by making calls to the Bitcoin Core RPC interface.</p> <p>On Mainnet the synchronisation process may take several hours to complete. Wait until it has finished before running the ION Core microservice in the following step.</p> <p>On Testnet4 the synchronisation process is much quicker, as there are fewer blocks to scan, and should take only a few minutes.</p> Troubleshooting Tips <ul> <li> <p>When running the ION Bitcoin microservice for the first time, it may fail with an error message similar to the following: <pre><code>Sidetree-Bitcoin node initialization failed with error: {\"stack\":\"Error: Unexpected fetch HTTP response: [500]: {\\\"result\\\":null,\\\"error\\\":{\\\"code\\\":-4,\\\"message\\\":\\\"Wallet already loading.\\\"}...}}\n</code></pre> This error can usually be overcome by simply re-starting the microservice with same command: <pre><code>(cd $ION_REPO &amp;&amp; npm run bitcoin)\n</code></pre></p> </li> <li> <p>If you see an <code>ECONNREFUSED</code> error message when starting the ION Bitcoin microservice, this indicates that it has failed to communicate with Bitcoin Core. In this case, make sure that Bitcoin Core started successfully.</p> </li> </ul> <p>In another new Terminal, start the ION Core microservice with: <pre><code>(cd $ION_REPO &amp;&amp; npm run core)\n</code></pre></p> Troubleshooting Tip <p>If you see an <code>ECONNREFUSED</code> error message when starting the ION Core microservice, this indicates that it has failed to communicate with the ION Bitcoin microservice. In this case, make sure that the ION Bitcoin microservice started successfully and is fully synchronised.</p> <p>Finally, to confirm that ION is working properly, open yet another new Terminal and resolve a sample DID:</p> MainnetTestnet4Testnet3 (Deprecated) <pre><code>curl http://localhost:3000/identifiers/did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w | json_pp\n</code></pre> <pre><code>curl http://localhost:3000/identifiers/did:ion:test:EiBt8NTmSKf3jt_FMKf-r6JMSJIp7njcTTPe24USYu4B9w | json_pp\n</code></pre> <pre><code>curl http://localhost:3000/identifiers/did:ion:test:EiClWZ1MnE8PHjH6y4e4nCKgtKnI1DK1foZiP61I86b6pw | json_pp\n</code></pre> <p>If ION is working properly, the command above will return a JSON data structure containing the resolved DID document and document metadata for the sample DID.</p> <p>Congratulations! Your ION installation is now complete.</p>"},{"location":"ion/#running-ion","title":"Running ION","text":"<p>The following commands must be run each time you start your ION node, e.g. after restarting your computer. Some of them will keep control of the Terminal, so you will need to open a new Terminal window to continue.</p> <p>Tip: Use tmux</p> <p>A convenient way to start all of the following processes is to use tmux (the terminal multiplexer). Once installed, open a tmux session with the command: <pre><code>tmux new -s ion\n</code></pre> and hit Ctrl+B followed by C each time you need to open a new window.</p> <p>When all of the processes are started, detach the tmux session with Ctrl+B followed by D. To reattach the session later, run: <pre><code>tmux a -t ion\n</code></pre></p> <p>Follow these steps to start your ION node:</p> <p>1. Start IPFS</p> <pre><code>ipfs daemon\n</code></pre> Other IPFS commands <p>Stop: <pre><code>ipfs shutdown\n</code></pre></p> <p>2. Start MongoDB</p> LinuxmacOS <pre><code>sudo systemctl start mongod\n</code></pre> Other MongoDB commands <p>Stop MongoDB: <pre><code>sudo systemctl stop mongod\n</code></pre> Restart: <pre><code>sudo systemctl restart mongod\n</code></pre> Check status: <pre><code>sudo systemctl status mongod\n</code></pre></p> <pre><code>brew services start mongodb-community\n</code></pre> Other MongoDB commands <p>Stop: <pre><code>brew services stop mongodb-community\n</code></pre> Restart: <pre><code>brew services restart mongodb-community\n</code></pre></p> <p>3. Start Bitcoin Core <pre><code>bitcoind\n</code></pre></p> Other Bitcoin Core commands MainnetTestnet4Testnet3 (Deprecated) <p>Check status: <pre><code>bitcoin-cli -getinfo\n</code></pre></p> <p>Stop Bitcoin Core: <pre><code>bitcoin-cli stop\n</code></pre></p> <p>Print the log file to the Terminal (hit Ctrl+C to exit): <pre><code>tail -f $BITCOIN_DATA/debug.log\n</code></pre></p> <p>Reindex the chain (may take &gt;1 hour): <pre><code>bitcoind -reindex-chainstate\n</code></pre></p> <p>Check which port bitcoind is listening on (should be 8333 for Mainnet): <pre><code>netstat -tulpn | grep 'bitcoind'\n</code></pre></p> <p>Check status: <pre><code>bitcoin-cli -getinfo\n</code></pre></p> <p>Stop Bitcoin Core: <pre><code>bitcoin-cli stop\n</code></pre></p> <p>Print the log file to the Terminal (hit Ctrl+C to exit): <pre><code>tail -f $BITCOIN_DATA/testnet4/debug.log\n</code></pre></p> <p>Reindex the chain (may take &gt;1 hour): <pre><code>bitcoind -reindex-chainstate\n</code></pre></p> <p>Check which port bitcoind is listening on (should be 48333 for Testnet4): <pre><code>netstat -tulpn | grep 'bitcoind'\n</code></pre></p> <p>Check status: <pre><code>bitcoin-cli -getinfo\n</code></pre></p> <p>Stop Bitcoin Core: <pre><code>bitcoin-cli stop\n</code></pre></p> <p>Print the log file to the Terminal (hit Ctrl+C to exit): <pre><code>tail -f $BITCOIN_DATA/testnet3/debug.log\n</code></pre></p> <p>Reindex the chain (may take &gt;1 hour): <pre><code>bitcoind -reindex-chainstate\n</code></pre></p> <p>Check which port bitcoind is listening on (should be 18333 for Testnet3): <pre><code>netstat -tulpn | grep 'bitcoind'\n</code></pre></p> <p>4. Start the ION bitcoin service. <pre><code>(cd $ION_REPO &amp;&amp; npm run bitcoin)\n</code></pre></p> <p>5. Start the ION core service. <pre><code>(cd $ION_REPO &amp;&amp; npm run core)\n</code></pre></p> <p>6. Test ION. To confirm that ION is working properly, resolve a sample DID:</p> MainnetTestnet4Testnet3 (Deprecated) <pre><code>curl http://localhost:3000/identifiers/did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w | json_pp\n</code></pre> <pre><code>curl http://localhost:3000/identifiers/did:ion:test:EiBt8NTmSKf3jt_FMKf-r6JMSJIp7njcTTPe24USYu4B9w | json_pp\n</code></pre> <pre><code>curl http://localhost:3000/identifiers/did:ion:test:EiClWZ1MnE8PHjH6y4e4nCKgtKnI1DK1foZiP61I86b6pw | json_pp\n</code></pre> <p>This command should print the contents of the resolved DID document and document metadata to the Terminal. If it does not, see the Troubleshoot tips above.</p>"},{"location":"ion/#funding-your-bitcoin-wallet","title":"Funding your Bitcoin wallet","text":"<p>ION can be used to resolve existing DIDs and to publish new ones. New DIDs are published by writing the DID document content to IPFS and inserting an identifier for that content inside a Bitcoin transaction. This has the effect of timestamping the DID document and also making it easily discoverable (by scanning the Bitcoin blockchain).</p> <p>Every Bitcoin transaction must include a processing fee, and therefore some funds must be available in your ION Bitcoin wallet before it can be used to publish any new DIDs. No funds are needed to resolve existing DIDs.</p> <p>First check that <code>sidetreeDefaultWallet</code>, that was created earlier, is loaded by running this command: <pre><code>bitcoin-cli listwallets\n</code></pre></p> <p>You should see the following output: <pre><code>[\n  \"sidetreeDefaultWallet\"\n]\n</code></pre> Then use this command to list the receiving addresses for this wallet (with their balances): <pre><code>bitcoin-cli -rpcwallet=\"sidetreeDefaultWallet\" listreceivedbyaddress 1 true\n</code></pre></p> <p>To fund your wallet, send Bitcoins to the first address in this list.</p> MainnetTestnet4Testnet3 (Deprecated) <p>Purchase BTC on a Bitcoin exchange</p> <p>If you do not already own any bitcoins, they can be purchased on a Bitcoin exchange. Make sure that you acquire genuine bitcoins, which are identified by the ticker symbol <code>BTC</code>. When withdrawing your coins from the exchange, enter the receive address obtained in the preceding step to send them to your ION wallet.</p> <p>After sending bitcoins to your wallet, you will need to wait for the transaction to be confirmed by the Bitcoin network. This should take around 10 minutes on average, but may take longer depending on the size of the transaction fee paid. To check the status of your transaction, paste the transaction ID into a Bitcoin blockchain explorer such as mempool.space.</p> <p>Request tBTC from a Testnet4 faucet</p> <p>Testnet4 bitcoins are identified by the ticker symbol tBTC, to distinguish them from the Mainnet bitcoins which have the symbol BTC.</p> <p>Since coins on Bitcoin Testnet4 have no monetary value they can be obtained free of charge from a \"faucet\", which is an automated service that will dispense a small quantity of tBTC on request.</p> <p>Visit a Bitcoin Testnet4 faucet, such as this one, and enter the recieve address obtained in the preceding step to send them to your ION wallet.</p> <p>After sending bitcoins to your wallet, you will need to wait for the transaction to be confirmed by the Bitcoin network. To check the status of your transaction, paste the transaction ID into a Bitcoin Testnet4 explorer such as mempool.space.</p> <p>Request tBTC from a Testnet3 faucet</p> <p>Testnet3 bitcoins are identified by the ticker symbol tBTC, to distinguish them from the Mainnet bitcoins which have the symbol BTC.</p> <p>Since coins on Bitcoin Testnet3 have no monetary value they can be obtained free of charge from a \"faucet\", which is an automated service that will dispense a small quantity of tBTC on request.</p> <p>Visit a Bitcoin Testnet3 faucet, such as coinfaucet.eu, and enter the recieve address obtained in the preceding step to send them to your ION wallet.</p> <p>After sending bitcoins to your wallet, you will need to wait for the transaction to be confirmed by the Bitcoin network. To check the status of your transaction, paste the transaction ID into a Bitcoin Testnet3 explorer such as mempool.space.</p> <p>When the transaction is confirmed, check your wallet balance with: <pre><code>bitcoin-cli getbalances\n</code></pre> The output should look something like this, with a non-zero balance for the <code>watchonly</code> wallet: <pre><code>{\n  \"mine\": {\n    \"trusted\": 0.00000000,\n    \"untrusted_pending\": 0.00000000,\n    \"immature\": 0.00000000\n  },\n  \"watchonly\": {\n    \"trusted\": 0.00017612,\n    \"untrusted_pending\": 0.00000000,\n    \"immature\": 0.00000000\n  }\n}\n</code></pre></p>"},{"location":"ion/#ssh-config","title":"SSH config","text":"<p>When running a remote ION node, it can be convenient to open an SSH connection (with port forwarding) from your local machine. This produces a setup that is indistinguishable from running ION locally.</p> <p>Allow incoming connections on the remote machine</p> <p>The remote machine must be configured to accept incoming connections on all of the ports listed below. If you are using a Virtual Machine from a cloud provider, this can be done from the Network Settings page in the management portal.</p> <p>We recommend adding the following lines to your SSH configuration file at <code>~/.ssh/config</code>:</p> MainnetTestnet4Testnet3 (Deprecated) <pre><code>Host ion\n    HostName &lt;IP_ADDRESS&gt;\n    User &lt;USERNAME&gt;\n    IdentityFile ~/.ssh/&lt;KEY_FILE&gt;\n    LocalForward 3000 localhost:3000\n    LocalForward 5001 localhost:5001\n    LocalForward 8332 localhost:8332\n    LocalForward 27017 localhost:27017\n</code></pre> <pre><code>Host ion\n    HostName &lt;IP_ADDRESS&gt;\n    User &lt;USERNAME&gt;\n    IdentityFile ~/.ssh/&lt;KEY_FILE&gt;\n    LocalForward 3000 localhost:3000\n    LocalForward 5001 localhost:5001\n    LocalForward 48332 localhost:48332\n    LocalForward 27017 localhost:27017\n</code></pre> <pre><code>Host ion\n    HostName &lt;IP_ADDRESS&gt;\n    User &lt;USERNAME&gt;\n    IdentityFile ~/.ssh/&lt;KEY_FILE&gt;\n    LocalForward 3000 localhost:3000\n    LocalForward 5001 localhost:5001\n    LocalForward 18332 localhost:18332\n    LocalForward 27017 localhost:27017\n</code></pre> <p>where <code>&lt;IP_ADDRESS&gt;</code> is the public IP address of the remote machine, <code>&lt;USERNAME&gt;</code> is the login username, and <code>&lt;KEY_FILE&gt;</code> is the name of the SSH key file used for key pair authentication.</p> <p>The port forwarding rules in the above configuration assume that the default ports are used for the following processes. These ports are shown in the following table. If you wish, you can change any of these ports by editing the ION configuration files as described earlier.</p> MainnetTestnet4Testnet3 (Deprecated) Port Process 3000 ION 5001 IPFS 8332 Bitcoin 27017 MongoDB Port Process 3000 ION 5001 IPFS 48332 Bitcoin 27017 MongoDB Port Process 3000 ION 5001 IPFS 18332 Bitcoin 27017 MongoDB <p>With this configuration in place, connect to the remote machine with the following command: <pre><code>ssh ion\n</code></pre></p> <p>As long as this connection is active, data sent to the ports specified in the SSH configuration (above) will be relayed to the same ports on the remote machine, producing a setup equivalent to running ION and its related processes locally.</p>"},{"location":"ion/#ion-using-docker","title":"ION using Docker","text":"<p>ION using Docker is read-only</p> <p>The simplest way to run ION is using Docker, and it can be a useful way to experiment with the system before performing a full installation. However, this method provides a read-only ION node. This means that it provides access to existing DIDs, but cannot be used to create and publish new ones.</p> <p>These instructions are based on the guide available on the ION GitHub repository.</p> <p>Step 1: Install Docker</p> LinuxmacOS <p>Install Docker: <pre><code>sudo apt-get update\nsudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common\n\ncurl -fsSL --max-time 10 --retry 3 --retry-delay 3 --retry-max-time 60 https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n\nsudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n\nsudo apt-get install -y docker-ce\nsudo systemctl enable docker\n</code></pre></p> <p>Install Docker Compose: <pre><code>sudo curl -L --max-time 60 --retry 3 --retry-delay 3 --retry-max-time 100 \"https://github.com/docker/compose/releases/download/v2.6.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\n</code></pre></p> <p>Install Docker Desktop.</p> <p>Step 2: Run the ION Docker container</p> <p>To access the required <code>docker-compose.*</code> files, enter the ION <code>docker</code> directory: <pre><code>cd $ION_REPO/docker\n</code></pre></p> <p>Now run the ION container. This command depends on whether you wish to run a Mainnet, Testnet4 or Testnet3 ION node:</p> MainnetTestnet4Testnet3 (Deprecated) <pre><code>docker-compose up -d\n</code></pre> <p>To run ION with Docker on Testnet4, the <code>docker-compose.testnet-override.yml</code> config file must be modified to set the correct RPC port number for the Bitcoin client:</p> LinuxmacOS <pre><code>sed -i 's|\"18332:18332\"|\"48332:48332\"|' $ION_REPO/docker/docker-compose.testnet-override.yml\n</code></pre> <pre><code>sed -i '' 's|\"18332:18332\"|\"48332:48332\"|' $ION_REPO/docker/docker-compose.testnet-override.yml\n</code></pre> <p>Then run the container with: <pre><code>docker-compose -f docker-compose.yml -f docker-compose.testnet-override.yml up -d\n</code></pre></p> <pre><code>docker-compose -f docker-compose.yml -f docker-compose.testnet-override.yml up -d\n</code></pre> <p>Bitcoin and ION synchronisation</p> <p>When the ION container starts for the first time, it will begin synchronising with the Bitcoin network. This means downloading all of the blocks in the Bitcoin blockchain, which is a large data structure containing every Bitcoion transaction that has ever been processed. Once this has finished, ION itself will then scan the entire blockchain for ION DID operations, which is also a lengthy process.</p> <p>In total, the synchronisation process may take several hours, or even days, to complete. You will not be able to use Trustchain until your ION node has finished synchronising.</p> <p>Fortunately, the synchronisation process on Testnet4 is much quicker, as only ~15GB of data must be downloaded.</p> <p>When the synchronisation process has finished, confirm that ION is working properly by running the following command to resolve a sample DID:</p> MainnetTestnet4Testnet3 (Deprecated) <pre><code>curl http://localhost:3000/identifiers/did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w | json_pp\n</code></pre> <pre><code>curl http://localhost:3000/identifiers/did:ion:test:EiBt8NTmSKf3jt_FMKf-r6JMSJIp7njcTTPe24USYu4B9w | json_pp\n</code></pre> <pre><code>curl http://localhost:3000/identifiers/did:ion:test:EiClWZ1MnE8PHjH6y4e4nCKgtKnI1DK1foZiP61I86b6pw | json_pp\n</code></pre> <p>If ION is working properly, the command above will return a JSON data structure containing the resolved DID document and document metadata for the sample DID.</p> <p> </p>"},{"location":"license/","title":"License","text":"<p>Trustchain is distributed under the terms of both the MIT license and the Apache License (Version 2.0).</p> <p>See LICENSE-MIT and LICENSE-APACHE for details.</p>"},{"location":"roles/","title":"User Roles","text":"<p>This page discusses the different roles that exist within a Trustchain user group. A user's role will determine which components of the Trustchain software suite they make use of, as summarised in the following table:</p> <p></p> Role Trustchain Mobile Trustchain using Docker Trustchain full installation Credential Holder Credential Verifier Credential Issuer dDID Subject dDID Issuer Root DID Subject"},{"location":"roles/#user-roles-example","title":"User Roles Example","text":"<p>To illustrate the various user roles, we use the concrete example of an individual holding a digital driver's licence issued by a national vehicle licensing agency. The holder of this credential will use it to provide proof of their registered driver status to a car rental company.</p>"},{"location":"roles/#credential-holder","title":"Credential Holder","text":"<p>A credential holder is an individual possessing one or more verifiable credentials (VCs) in which they are the subject. Holders have the ability to generate verifiable presentations (VPs) from their credentials.</p> <p>Example: Digital driver's licence holder</p> <p>An individual holding a digital driver's license in a credential wallet on their mobile device is a credential holder.</p> <p>The Trustchain Mobile app includes a credential wallet which enables the individual to receive the credential from a verified URL, confirm the validity of the received credential, store the credential and subsequently present it to a third party, such as a car hire company.</p>"},{"location":"roles/#credential-verifier","title":"Credential Verifier","text":"<p>A credential verifier is an individual or legal entity that can verify presentations shared by a credential holder (and derived from one or more of their credentials).</p> <p>This involves retrieving the credential issuer's public key via the Trustchain verifiable public key infrastructure, and then using it to verify the issuer's signature on the presentation. The credential verifier also verifies the holder's signature on the presentation, and its timestamp, thereby confirming that the presentation was not generated in advance by another party in possession of the holder's private key.</p> <p>To verify the holder's signature, the credential verifier must also have access to the holder's public key, which can be shared either via the Trustchain PKI or by using the <code>did:key</code> method, in which the holder's public key is embedded inside their DID identifier.</p> <p>Example: Car hire company</p> <p>Before authorising a vehicle rental, a car hire company must establish that their client is in possession of a valid driving licence. They must also confirm certain information about the driver, such as their full name, driver number and country of residence.</p> <p>The credential holder generates a verifiable presentation containing this information and shares it with the car hire company, either by uploading it to their server or by generating a QR code for direct sharing between devices.</p> <p>Having received the presentation, an employee of the rental company is able to verify the signatures on it using either the Trustchain Mobile app or a full Trustchain installation if available. This employee is a credential verifier. The presentation will also contain the personal details shared by the holder, which are covered by the issuer's signature and therefore known to be genuine.</p>"},{"location":"roles/#credential-issuer","title":"Credential Issuer","text":"<p>A credential issuer is a legal entity that issues a verifiable credential to an individual to which they attach their signature, thereby attesting to the validity of the information contained in the credential.</p> <p>Credential issuers must run a full Trustchain node. By running the built-in Trustchain HTTP server they can expose a service endpoint (URL) for issuing credentials and/or responding to requests from the Trustchain Mobile client.</p> <p>Example: Driver and Vehicle Licensing Agency</p> <p>The government agency responsible for issuing driver's licences is the credential issuer.</p>"},{"location":"roles/#ddid-subject","title":"dDID Subject","text":"<p>A downstream DID (dDID) subject is a legal entity or individual whose DID appears in the <code>id</code> field of a DID, which itself bears an attestation (signatuare) from an upstream entity.</p> <p>Downstream DID subjects must run a full Trustchain node in order to participate in the challenge-response process through which a dDID is issued.</p> <p>Example: Driver and Vehicle Licensing Agency</p> <p>In our example, the Driver and Vehicle Licensing Agency is both a credential issuer and a dDID subject. Indeed, it is the agency's status as a dDID subject that makes it possible for it to issue credentials that can be subsequently verified by a credential verifier.</p>"},{"location":"roles/#ddid-issuer","title":"dDID Issuer","text":"<p>A downstream DID (dDID) issuer is a legal entity or individual whose DID appears in the <code>controller</code> field of a downstream DID. A dDID issuer is therefore necessarily also an upstream DID (uDID) subject.</p> <p>Downstream DID issuers must run a full Trustchain node in order to participate in the challenge-response process through which a dDID is issued.</p> <p>Example: Government Department for Transport</p> <p>Suppose that the Driver and Vehicle Licensing Agency is overseen by the government's Department for Transport. In that case, the agency's dDID would be signed by that government department, which itself is represented by a uDID. This makes the Department for Transport a dDID issuer.</p>"},{"location":"roles/#root-did-subject","title":"Root DID Subject","text":"<p>The root DID subject is the legal entity (or group of entities) whose DID appears in the <code>id</code> field of the root DID.</p> <p>The root DID sits at the top of the hierarchical DID structure. Therefore the root DID subject is not a downstream DID subject and there is no signature of attestation on the root DID document. Instead, the contents of the root DID document are verified by checking that it was published on a particular date, as explained in the FAQs.</p> <p>Example: Central government</p> <p>In a national digital ID system the central government would be a natural choice for root DID subject. They would act as the first dDID issuer and would issue a dDID to each government department, including the Department for Transport.</p> <p> </p>"},{"location":"technical-notes/","title":"Technical Notes","text":""},{"location":"technical-notes/#independently-verifiable-timestamping","title":"Independently Verifiable Timestamping","text":"<p>Trustchain adopts the W3C standard for Verifiable Credentials (VCs) and specifies the precise nature of the Verifiable Data Registry which plays a central role in the VC data model. The main purpose of this data registry is to store Decentralised Identifiers (DIDs) and associated DID Documents containing public key information.</p> <p>The data registry employed by Trustchain enables independent verification of:</p> <ol> <li>the timestamps associated with DIDs and DID Documents (including metadata),</li> <li>the content of those DID Documents.</li> </ol> <p>In other words, anybody who wishes to do so can verify that a particular Trustchain DID was published at a particular date/time, and that the content of the associated DID Document has not been modified since that time.</p> <p>Several core operations in Trustchain depend on this ability to create (DIDs) with independently verifiable timestamps, as explained in the FAQ. Here we explain the verification mechanism.</p> <p>Trustchain delegates the process of DID creation and timestamping to the Identity Overlay Network (ION), open source software from the Decentralized Identity Foundation. The verifiable timestamping mechanism delivered by ION, and leveraged by Trustchain, ultimately depends on the continuous and cumulative proof of work performed by the Bitcoin network. It involves embedding IPFS content identifiers (cryptographic hash digests) into Bitcoin transactions, thereby furnishing the IPFS content (DID documents, in this case) with the same timestamp as the transaction itself.</p> <p>Anybody can verify that a particular Bitcoin transaction is contained in a particular block by executing a series of SHA256 hash operations and comparing the result to the hash digest found inside the block header. By performing a similar process for each subsequent block, they can accurately estimate the amount of work done to produce the \"strongest\" (i.e. most computationally expensive) chain of blocks.</p> <p>Since this work would need to be re-done by anyone attempting to modify the block containing the transaction of interest, the verifier can infer a realistic estimate of the computational cost of falsifying such a timestamp. And from this computational cost, the economic cost of such an attack can be estimated.</p> <p>Very little computational effort is required to perform the verification, and the blockchain data structure contains all of the information needed to verify the timestamp, so no trust in any third party is required.</p> <p>At the time of writing (April 2022), the total hash rate of the Bitcoin network is &gt;600 EH/s and the theoretical cost (in USD) to modify the history of the chain, as a function of the temporal depth of the attack, is as follows:</p> 0 1 hour 1 day 1 week 1 month ~$1 $3.4m $81.0m $566.8m $2.463b <p>We can see that it is very cheap to create honest timestamps but very expensive to create deceptive ones. (In addition, any attempt at deception would be immediately observable by all nodes on the Bitcoin network.)</p> <p>In this way, the timestamp on a transaction (and hence on a DID Document) can be verified in a quantitative manner by computing how expensive it would be to execute an attack to produce a deceptive timestamp.</p>"},{"location":"technical-notes/#downstream-dids","title":"Downstream DIDs","text":"<p>A downstream DID (dDID) is a decentralised identifier in which the trustworthiness of the information contained in the corresponding DID document is attested to by an upstream entity, whose identity is itself represented by an upstream DID (uDID). The act of creating a dDID is an assertion, on the part of the upstream entity, of their confidence in the trustworthiness of the identifying information contained in the dDID document. In particular, it is an assertion that downstream entity is in sole possession of the private keys corresponding to the public keys found in the dDID document.</p> <p>In a dDID the DID subject refers to the downstream entity and the DID controller is the upstream entity that signs the dDID document, thereby attesting to its trustworthiness. The <code>controller</code> property in the dDID must therefore contain a string matching that of the <code>id</code> property in the uDID.</p> <p>The signature of controller is stored in the DID Document Metadata.</p> <p>This signature represents an assertion by the upstream entity and therefore the public key with which the signature can be verified must be that contained in the <code>assertionMethod</code> property of the uDID. That is, for verification purposes, the dDID is treated in exactly the same way as a Verifiable Credential (VC) issued by the upstream entity; the proof contained in the dDID document metadata conceptually makes the dDID into a credential in which the subject is the downstream entity.</p> <p></p> <p>Here the public key PKu is value associated with the <code>assertionMethod</code> property in the uDID (i.e. it's the public key used to verify assertions made by the upstream entity). The signature is on the dDID is just such an assertion. It is stored in the dDID Document Metadata and verified using PKu.</p> <p>Similarly, PKd is the value associated with the <code>assertionMethod</code> property in the dDID. It provides the verification method for further dDIDs and/or VCs issued by the downstream entity.</p>"},{"location":"technical-notes/#upstream-did-key-rotation","title":"Upstream DID Key Rotation","text":"<p>When keys are rotated in an upstream DID, attestations that depend on the expiring keys must be reinstated using the new keys if the same network structure is to be preserved.</p> <p>These renewed attestations should be included in the same batch of DID operations as the uDID update operation itself, to avoid any interruption to the services provided by the Trustchain infrastructure.</p> <p>Attestations made with keys that are common to both the original and updated uDID need not be renewed, as there will still exist a verifiable chain of attestations via the new path. In this case the dDID will be older than the uDID, but the attestation remains valid because the chronological order in which upstream and downstream DIDs are published is unimportant; what matters is that the signature on the dDID can be verified using a key in the uDID.</p>"},{"location":"technical-notes/#root-did-key-rotation","title":"Root DID Key Rotation","text":"<p>Root DID key rotation is more subtle than regular uDID key rotation (considered above) because here the chronological order of events does matter. An updated root DID will have a timestamp that differs from the generally accepted root event time and therefore, even if all downstream attestations are reinstated, every dDID verification attempt will fail.</p> <p>The solution is to slightly relax the condition for a root DID to be considered valid. It will be valid if either:</p> <ul> <li>its timestamp matches the known root event time, or</li> <li>its chain of update (or recovery) operations can be traced back to a DID whose timestamp matches the root event time.</li> </ul>"},{"location":"technical-notes/#root-did-update-and-recovery-secrets","title":"Root DID Update and Recovery Secrets","text":"<p>If the root DID update secret is compromised then an attacker could insert their own keys and/or remove the legitimate keys in an updated root DID document. The only defence against such an attack would be to use the recovery secret to recover the root DID (with a new update secret).</p> <p>If the root DID recovery secret is compromised then an attacker could acquire complete and irrevocable control over the contents of the root DID document. The only defence in that case would be for the genuine root entity to execute the recovery operation first, thereby introducing a new recovery secret. Otherwise the whole network must be abandoned.</p> <p>However, both of these risks can be reduced dramatically by including multiple secrets in the pre-image of the update and recovery commitments and then dividing those secrets among multiple parties. Any update or recovery operation would then require the cooporation of several different parties and therefore the compromise of any one (or small number) of the secrets would not result in a vulnerability.</p>"},{"location":"technical-notes/#constrained-ddids","title":"Constrained dDIDs","text":"<p>This idea was inspired by our analysis of the existing Web PKI and in particular the problem of \"surprising certificates\".</p> <p>In the Web PKI context, a mitigation strategy against surprising certificates is for root Certification Authorities (CAs) to impose name constraints on the certificates that can be issued by their subordinate CAs. For instance, the subordinate may only be allowed to issue a certificate under a particular top-level domain. The mechanism for enforcing these constraints is via guidelines that encourage browser vendors to check for violations.</p> <p>Our aim, in the context of a decentralised PKI for digital identity, is to enforce constraints on the issuance of DIDs cryptographically, rather than merely encouraging software vendors to police them.</p> <p>The aim is to enable an upstream entity to issue a downstream DID to another (subordinate) entity that delegates permission for them to extend the chain of trust further by issuing their own dDIDs, but also imposes constraints on the nature (i.e the contents) of those dDIDs.</p> <p>The types of constraints imagined include:</p> <ul> <li>name constraints on service endpoint URIs (or other network addresses)</li> <li>constraints on allowed verification methods</li> <li>constraints on the existence (or otherwise) of particular DID data &amp; metadata parameters</li> <li>constraints on the types of VCs that can be issued.</li> </ul> <p>The proposed enforcement mechanism is via the verification method (e.g. public key) specified in the <code>assertionMethod</code> property of the constrained dDID issued to the subordinate entity.</p> <p>As explained above, in the standard (unconstrained) case the <code>assertionMethod</code> property in the uDID is used to express the public key with which to verify the attestation signature on the dDID. Therefore, when permission to issue DIDs further downstream is delegated to a subordinate entity, it is the public key of the subordinate entity that belongs in the <code>assertionMethod</code> property.</p> <p>In the constrained case, however, the <code>assertionMethod</code> instead contains a 2-of-2 multi-signature public key that represents both the subordinate and the upstream (delegating) entity. This means that any lower-level dDID issued by the subordinate must be signed by both the subordinate and the superior entity. The subordinate is prevented from issuing their own dDIDs without first obtaining the signature of their uDID superior.</p> <p></p> <p>The key difference, versus the unconstrained case, is that the <code>assertionMethod</code> property in the Constrained dDID is a linear combination of the public keys of the upstream and subordinate entities (PKu and PKd). This aggregated public key can be used to verify a multi-signature produced by both entities (assuming here a Schnorr multi-signature scheme such as MuSig2; there are others of course).</p> <p>When the subordinate entity wants to issue a dDID, it collects the information and constructs a candidate DID document but does not attempt to publish it (because, without the upsteam entity's signature, this new dDID is invalid). To get the upstream entity's signature, the subordinate makes a call the the upstream entity's Web API (using an endpoint specified in their own uDID), requesting their signature and passing the candidate DID document.</p> <p>The call to the upsteam entity's Web API returns a conditional signature that is valid if and only if the exact same DID document is subsequently signed by the subordinate entity. The API call provides the upstream entity with the opportunity to check that the constraint is not violated. The business logic behind the API endpoint takes the candidate DID document, checks the constraint, hashes the document, signs the hash and returns the conditional signature. If the candidate DID violates the constraint, an error is returned by the API.</p> <p>Assuming the constraints are respected, the subordinate entity now has a partially-signed hash of the candidate dDID document, and only needs to add its own signature to make it a valid dDID that can be published.</p> <p>Notice that the upstream entity does not need to be directly involved in the construction of the final dDID, except by exposing the Web API, because the logic for checking the constraint can be encoded and a conditional signature provided automatically that will only be valid if the final version of the dDID exactly matches that which was sent to the API.</p> <p>Also, the reference software client can include the API logic so the upstream entity need only specify the particular constraints they wish to impose on the subordinate at the time of creating their dDID, and the rest is automatic.</p> <p>One might ask: what is the point of the subordinate dDID in this scenario? Since a signature from the upstream entity is required anyway, why bother with the multisignature involving both the upstream and subordinate entities? The point is that the attestion as to the correctness of the information in the final dDID is being made by the subordinate, not the upstream entity. It is the subordinate that is responsible for collecting and verifying the information contained, and this should not be confused with (or made equivalent to) the case where the upstream entity issues its own dDIDs. In particular, we want to be able to revoke the subordinate's dDID (thereby automatically revoking any of their downstream DIDs) without affecting the status of the upstream entity's DID.</p> <p>While the above seems like it might work in practice, there are some open research questions associated with this idea, in particular:</p> <ul> <li>Is the Schnorr signature aggregation approach, assumed above, the best way to implement the multi-signatures required for this scheme, or are other cryptographic protocols (e.g. using conditional signatures) available that offer advantages?</li> <li>Is it possible to achieve a similar result without requiring an interactive signing protocol at all? That is, could cryptographic constraints be built into dDIDs at the point of creation, without requiring any further involvement from the upstream entity?</li> </ul>"},{"location":"technical-notes/#constrained-vc-issuance","title":"Constrained VC Issuance","text":"<p>The mechanism outlined above for imposing constraints on the nature of the dDIDs that can be created by a subordinate entity could also be used to restrict the nature of the Verifiable Credentials that they can issue.</p> <p>To see this, observe that a dDID is itself a form of VC, and therefore constrained dDIDs are in fact a special case of constrained VC issuance.</p> <p>As a concrete example, suppose the upstream entity is a central bank and the subordinate is a commercial bank. Now suppose that an insider at the commercial bank is prepared to issue fraudulent VCs (for a fee) that attest to an individual having Legal Disability Status, which would entitle the individual to certain benefits.</p> <p>The commercial bank is a recognised by the central bank as a legitimate issuer of VCs pertaining to certain attributes, such as minimum age, employment status, creditworthiness etc., but can not legitimately attest to an individual's disability status.</p> <p>Constrained VC issuance refers to the idea that the dDID created by the upstream entity (the central bank) constrains the attributes that can be attested to in VCs issued by the subordinate entity (the commercial bank). Any VC that violates these constraints is referred to as transgressive.</p> <p>One way to impose this constraint would be to embed metadata in the dDID specifying which VC attributes can legitimately be attested to by the dDID subject. However, this would require the verifier's client software to faithfully check that metadata and reject a VC if it violated the given constraints, even if the signature on the VC and the trustchain of the dDID were valid. There is no way to guarantee that the client software would correctly perform this additional check.</p> <p>The constrained VC approach is much more robust. In this case, the VC must be signed by both the upstream and subordinate entities, giving the upstream entity an opportunity to check that the attribute constraints have not been violated. This makes it impossible for the subordinate to issue a transgressive VC.</p> <p>Because the check that the upstream entity performs, in order to verify that the candidate VC does not violate any of the desired constraints, is fully automated (requiring only a Web API call), this approach can scale to the case of VCs which are likely to be issued at a much higher frequency than dDIDs.</p>"},{"location":"technical-notes/#rebasing","title":"Rebasing","text":"<p>Suppose two independent root transactions are created by two separate user communities. Each then builds a tree of trust relationships branching out from their respective roots, in the form of chains of downstream DIDs.</p> <p>At some later date, there may be a mutual agreement that one community should assimilate the other, by enabling chains of trust from (part or all of) tree \\(B\\) to be traced back to the root of tree \\(A\\).</p> <p>This can be achieved by simply creating a dDID on tree \\(A\\) that duplicates an existing DID in tree \\(B\\) (which may be the root of tree \\(B\\), but need not be). All DIDs on tree \\(B\\) that are downstream of the duplicated DID are automatically included in tree \\(A\\), since there now exists a valid chain of trust to its root.</p> <p>We refer to this operation as rebasing, because it is somewhat similar to the rebase operation found in the Git version control system.</p> <p>The act of rebasing revokes (i.e. invalidates) the original DID on tree \\(B\\), because (according to the DID standard) the latest valid DID overrides any earlier ones. Note that this does not invalidate the DIDs that are downstream of the rebased node on tree \\(B\\), provided the same keys are included in the rebased DID.</p> <p>Since those dDIDs in tree \\(B\\) existed before the rebasing operation was performed, the timestamps on a rebased trustchain will not necessarily follow reverse chronological order (back to the root) as would be expected in a regular chain. In itself this is not problematic, because the authenticity of the chain is assured by the validity of the chain of signatures, not by the downstream timestamps. However further assurance could be provided by attaching metadata to the rebased DID indicating that any chain involving it may legitimately include non-chronological timestamps.</p> <p>The option to rebase one root or branch onto another tree may be beneficial for adoption of the technology, as it enables different groups to begin using the system independently without leading to permanently parallel and disconnected systems.</p> <p>This feature also promotes one of the key benefits of decentralisation, namely permissionless access, since marginalised communities can establish their own roots of trust and make use of the technology without accepting or contributing to the possibility of long-term exclusion.</p>"},{"location":"technical-notes/#root-did-integration","title":"Root DID Integration","text":"<p>Suppose (as in the Rebasing section above) two independent root DIDs have been created by two separate user communities, each with its own network of trust relationships represented by chains of downstream DIDs.</p> <p>At some later date there may be a mutual agreement to fuse the two networks into a single one, but (unlike the case above) suppose that neither of the root entities is prepared to be subordinated by the other.</p> <p>In this situation the two networks can be integrated by publishing a new root DID, whose set of public keys is the union of the public keys from each of the original roots. Those two root DIDs are then updated to become downstream DIDs of the new root. In each case, the dDID attestation is made using the signing key from the original root, so it is clear that the original root entity is attesting to itself.</p> <p>Users on both networks would need to reconfigure the root event time on their Trustchain nodes to match the publication time of the new integrated root DID. Once this is done, all credentials that were previously issued will remain valid and will now be verifiable by participants on both networks.</p> <p>Here we have considered integrating two root DIDs, but the same approach works equally well for larger numbers.</p>"},{"location":"technical-notes/#interoperability-ddids","title":"Interoperability dDIDs","text":"<p>The concept of an Interoperability dDID provides a means to support loosely-coupled federation across multiple, pre-existing digital ID systems in which Verifiable Credentials (VCs) are issued either by an identity provider itself, or by a recognised (subordinate) issuer.</p> <p>For simplicity, we consider the case of two national ID systems, administered by entities we refer to as Local and Remote. In the Trustchain model both entities are represented by DIDs, which are themselves downstream from some root DID. The root may be common to both or distinct (in which case Local and Remote occupy disjoint trust networks).</p> <p>Suppose Alice, a user who is registered in the Local system, has a credential issued by the Local ID provider, which she can use to prove certain individual attributes about herself. A verifier operating within the Local system will be able to verify the signature on Alice's credential by resolving the Local ID provider's DID document to retrieve their public key.</p> <p>Now suppose Alice travels to the country where the Remote entity operates the national ID system, and she wishes to use the same credential. As things stand this will not be possible, because verifiers will only accept credentials signed by the Remote entity (i.e. their own national ID provider), or a recognised subordinate thereof.</p> <p>Before the two systems can become interoperable some sort of \"Trust Framework\" must be established between the Local and Remote entities, including a formal agreement to recognise credentials issued by the foreign system. Such frameworks necessarily take into account a variety of considerations (legal, regulatory, political, etc.) which are outside the scope of any technical solution. However, there remains the technical question of how a formal policy agreement is brought into effect in a live digital ID system. This is where the interoperability dDID can play a role.</p> <p>A trust agreement between the Local and Remote ID providers is embodied in a new downstream DID, jointly signed by both entities. This interoperability dDID  represents a new combined entity, and the corresponding DID document includes the public keys already associated with each of the individual providers (in their own DID documents) for the purpose of VC issuance.</p> <p>As soon as the interoperability dDID is published, it is automatically downloaded and verified by users and verifiers in both systems.</p> <p>Now, when Alice presents her credential to the Remote verifier she also shares a reference to the interoperability dDID. The verifier resolves the corresponding DID document to obtain the public keys of the Local entity, with which they can verify the authenticity of Alice's credential. The verifier also checks the chain of signatures on the interoperability dDID and finds a valid chain leading to the DID of the Remote ID provider, which is already recognised (and can be re-verified back to the trusted root if necessary).</p> <p>Through this mechanism, credentials previously issued under either the Local or Remote system become instantly verifiable in the other system as soon as the interoperability dDID is published.</p> <p>By selecting which keys to include in the interoperability dDID, the Local and Remote ID providers can be selective about which sets of credentials should be included within the terms of the trust agreement.</p> <p>In this example we have considered federation across two pre-existing digital ID systems, but the same mechanism could be applied to enable interoperability between larger groups. Provided the interoperability dDID is signed by all participating entities, and contains the relevant keys from each, it scales to groups of any size.</p> <p>In order to achieve a similar arrangement, without the means of an open &amp; shared public key infrastructure, bilateral or multilateral agreements between identity providers would need to be securely communicated to all users and relying parties, including updating lists of trusted public keys on their client devices. In that scenario device updates would become an attack vector and, in the absence of a universally accessible &amp; verifiable \"ground truth\", the shared state across different participants in the system could easily become unsynchronised.</p> <p> </p>"},{"location":"usage/","title":"Usage","text":"<p>This page contains instructions for using the Trustchain command line interface (CLI).</p> <p>Depending on your role within the network of Trustchain users you may need to perform some or all of the operations described below. For more information, see the User Roles page.</p> <p>Prerequisites</p> <p>To use the Trustchain CLI, first make sure that you have followed the installation and configuration instructions on the Getting Started page.</p> <p>Your ION node will also need to be up and running, either locally or on a remote machine to which you are connected via SSH and with port forwarding. Instructions for restarting ION, and setting up port forwarding, can be found here.</p>"},{"location":"usage/#trustchain-cli","title":"Trustchain CLI","text":"<p>To invoke the Trustchain CLI, open a Terminal and run this command: <pre><code>trustchain-cli\n</code></pre> You should see a list of available commands and some usage hints.</p> <p>If instead you get an error that the <code>trustchain-cli</code> command is not found, make sure you have followed all of the installation steps on the Getting Started page.</p> <p>The CLI is organised into a set of subcommands for different types of operation:</p> Subcommand Description <code>did</code> DID functionality: create, attest, resolve, verify. <code>vc</code> Verifiable credential functionality: sign and verify. <code>data</code> Data provenance functionality: sign and verify. <code>cr</code> Challenge-response functionality for dDID issuance. <p>To get help with a particular subcommand, use the <code>--help</code> flag (or <code>-h</code> for short). For example, to get help with the CLI commands relating to DIDs: <pre><code>trustchain-cli did --help\n</code></pre></p>"},{"location":"usage/#did-resolution","title":"DID Resolution","text":"<p>DID Resolution is a process defined in the W3C standard for Decentralised Identifiers (DIDs).</p> <p>It takes as input a DID (string identifier) and returns the corresponding DID document, containing the public keys and service endpoints (URLs) that belong to the legal entity that is the DID subject. DID document metadata is also returned.</p> <p>To resolve a DID using the Trustchain CLI, execute this command replacing <code>&lt;DID&gt;</code> with the DID of interest: <pre><code>trustchain-cli did resolve --did &lt;DID&gt;\n</code></pre></p> <p>If the DID is found, the complete DID document (and document metadata) will be printed to the terminal.</p> MainnetTestnet4Testnet3 (Deprecated) <p>Example: DID resolution on Mainnet</p> <p>To test that Trustchain and ION are working correctly, try resolving this example DID: <pre><code>trustchain-cli did resolve --did did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w\n</code></pre></p> <p>Example: DID resolution on Testnet4</p> <p>To test that Trustchain and ION are working correctly, try resolving this example DID: <pre><code>trustchain-cli did resolve --did did:ion:test:EiBt8NTmSKf3jt_FMKf-r6JMSJIp7njcTTPe24USYu4B9w\n</code></pre></p> <p>Example: DID resolution on Testnet3</p> <p>To test that Trustchain and ION are working correctly, try resolving this example DID: <pre><code>trustchain-cli did resolve --did did:ion:test:EiClWZ1MnE8PHjH6y4e4nCKgtKnI1DK1foZiP61I86b6pw\n</code></pre></p>"},{"location":"usage/#did-issuance","title":"DID Issuance","text":"<p>With the Trustchain CLI, you can create and publish your own Decentralised Identifiers. This process must be carried out by the DID subject because it involves generating new public-private key pairs.</p>"},{"location":"usage/#did-document-content","title":"DID document content","text":"<p>Use the template below to create a JSON object that will be included in your new DID document. This JSON object may include either or both of the <code>services</code> in the template.</p> <p>Services are part of the W3C DID specification. They are used in DID documents to express ways of communicating with the DID subject via a service endpoint (URL), and can relate to any type of service the DID subject wants to advertise.</p> <p>In the template below:</p> <ul> <li>the first service has type <code>Identity</code> and is used to identify the DID subject by their Web domain,</li> <li>the second service has type <code>CredentialEndpoint</code> and can be used by credential issuing authorities to advertise their issuance endpoint (URL).</li> </ul> <p>Other services may also be included, at the DID subject's discretion.</p> <p>Using a text editor, make a copy of the following template and modify it so it contains the services and endpoints that you wish to include in your DID, then save the file.</p> <p>The file can be saved anywhere, but we recommend storing it in a directory named <code>doc_states</code> inside the <code>TRUSTCHAIN_DATA</code> directory. That way it will be easy to find later, when you use it to create your DID document.</p> <pre><code>{\n   \"services\": [\n      {\n         \"id\": \"TrustchainID\",\n         \"type\": \"Identity\",\n         \"serviceEndpoint\": \"https://www.example.com\"\n      },\n      {\n         \"id\": \"TrustchainHTTP\",\n         \"type\": \"CredentialEndpoint\",\n         \"serviceEndpoint\": \"https://example.com/credentials\"\n      }\n   ]\n}\n</code></pre>"},{"location":"usage/#create-the-did","title":"Create the DID","text":"<p>Having defined the document content, we can now use the Trustchain CLI to create the DID itself. Run the following command, replacing <code>&lt;DID_CONTENT_FILE&gt;</code> with the path to the DID document content file (from the previous step): <pre><code>trustchain-cli did create --file_path &lt;DID_CONTENT_FILE&gt;\n</code></pre></p> <p>Example: DID creation</p> <p>Suppose you named your DID document content file <code>did_content.json</code> and saved it in the folder <code>$TRUSTCHAIN_DATA/doc_states/</code>. Then you would create the DID with the following command: <pre><code>trustchain-cli did create --file_path $TRUSTCHAIN_DATA/doc_states/did_content.json\n</code></pre></p> <p>The <code>create</code> command prints the new DID in the terminal window.</p> <p>It also creates a new file inside the folder <code>$TRUSTCHAIN_DATA/operations/</code>. To see the contents of this file, replace <code>&lt;DID&gt;</code> with the newly-created DID in the following command: <pre><code>cat $TRUSTCHAIN_DATA/operations/create_operation_&lt;DID&gt;.json\n</code></pre></p> <p>Inside this file you will be able to see the services inserted from the DID document content file.</p> <p>You will also see a public key of type <code>JsonWebSignature2020</code>. This public key was generated automatically by the Trustchain CLI and inserted into the file, so it will be part of the published DID document content.</p> <p>The counterpart private key was saved at <code>$TRUSTCHAIN_DATA/key_manager/</code> in a subfolder with the same name as the DID. This private key will enable the DID subject to perform signing operations, such as attesting to downsteam DIDs or digital credentials. Anyone will be able to verify those digital signatures by obtaining the corresponding public key from the published DID document.</p> <p>In fact, three private key were generated by the CLI when the DID was created. All are contained in the same subfolder which will now contain the following files:</p> Filename Description <code>signing_key.json</code> Private key counterpart to the public key in the DID document. <code>update_key.json</code> Private key required to make the next update to the DID document. <code>recovery_key.json</code> Private key required to recover the DID (in case other keys are lost/compromised). Can my DID document contain multiple signing keys? <p>By default, a single public-private key pair is automatically generated for all signing/attestation purposes. However, it is possible to include multiple keys in a single DID document.</p> <p>This can be useful if different keys are intended to be used for different purposes, or if the DID refers to an organisation in which different individuals or departments wish to hold their own keys.</p> <p>To include multiple public keys in your DID document, simply include them in the DID document content before creating the DID, as in this example: <pre><code>{\n    \"publicKeys\": [\n        {\n            \"id\": \"D6eRSvf6rIfhmPqQDkoCnDVnMzA3lqUPG-2VxIAm0j8\",\n            \"type\": \"JsonWebSignature2020\",\n            \"publicKeyJwk\": {\n                \"kty\": \"EC\",\n                \"crv\": \"secp256k1\",\n                \"x\": \"WxRuakVQKfKPs70LwvZnvr1UhhVd2QPtu4PfEc5os_M\",\n                \"y\": \"4lb0D5ORUnsEU_Oh1xp19CzltTDH7IBVp2B0ZEU1qQs\"\n            },\n            \"purposes\": [\n                \"assertionMethod\",\n                \"authentication\",\n                \"keyAgreement\",\n                \"capabilityInvocation\",\n                \"capabilityDelegation\"\n            ]\n        },\n        {\n            \"id\": \"u4HckebM8ltNrU_8qOXtSD1SIE6mlCskFR7p0vTFd3U\",\n            \"type\": \"JsonWebSignature2020\",\n            \"publicKeyJwk\": {\n                \"kty\": \"EC\",\n                \"crv\": \"secp256k1\",\n                \"x\": \"459af8dOpARVLRbozIvdQPGK9rTCh1e2ZVipBn8E5Lk\",\n                \"y\": \"Rn6iPKS1cNU73eoQpaYt0Z8q3t9duOZNolJEFdAaFS0\"\n            },\n            \"purposes\": [\n                \"assertionMethod\",\n                \"authentication\",\n            ]\n        }\n    ],\n    \"services\": [\n        {\n            \"id\": \"TrustchainID\",\n            \"type\": \"Identity\",\n            \"serviceEndpoint\": \"https://www.example.com\"\n        }\n    ]\n}\n</code></pre> Then run the usual command to create the DID: <pre><code>trustchain-cli did create --file_path &lt;DID_CONTENT_FILE&gt;\n</code></pre> When a list of public keys is specified in the DID document content (as above), Trustchain will not generate any new signing keys when creating the DID.</p> <p>To enable Trustchain's key management system to access the corresponding private keys, for signing purposes, you will need to copy and paste those private keys into a file named <code>signing_key.json</code> inside the key manager folder: <pre><code>$TRUSTCHAIN_DATA/key_manager/&lt;DID&gt;/signing_key.json\n</code></pre> where <code>&lt;DID&gt;</code> is the particular DID in question.</p> <p>The format of the <code>signing_key.json</code> file must be a list: <pre><code>[\n    KEY1,\n    KEY2,\n    ...\n]\n</code></pre> where <code>KEY1</code>, <code>KEY2</code>, etc. are how they would appear if the individual keys were in a file on their own.</p> <p>Full support for managing DIDs with multiple keys will be added in a future version of the Trustchain CLI.</p>"},{"location":"usage/#publish-the-did-document","title":"Publish the DID document","text":"<p>Note: Publishing new DIDs requires a funded Bitcoin wallet</p> <p>Publishing a Trustchain DID involves embedding information into a Bitcoin transaction and broadcasting it to the Bitcoin network. This makes the information accessible to everyone, globally, via the Bitcoin transaction ledger.</p> <p>This process will be taken care of by the Trustchain CLI, via the embedded ION node which itself contains a node on the Bitcoin network. However, since each Bitcoin transaction includes a processing fee, you must have funds in your Bitcoin wallet before publishing any DIDs.</p> <p>Instructions on how to fund your Bitcoin wallet are available here.</p> <p>Currently the Trustchain CLI does not include a command for publishing DIDs. This will be added in a future version. In the meantime, DIDs can be published by running a script from the command line.</p> <p>Note: The publish script assumes the default ION port number (3000)</p> <p>By default, the ION server listens on port 3000. If you have configured ION to listen on a different port, you will need to manually edit the publish script. If you are unsure, view the ION config file with this command: <pre><code>cat $ION_CORE_CONFIG_FILE_PATH\n</code></pre> and check the value of the <code>port</code> parameter. If the value is not <code>3000</code>, you will need to change the value of the <code>port</code> variable at the top of the publish script to have the same value. To edit the script, run: <pre><code>nano \"$TRUSTCHAIN_REPO\"/scripts/publish.sh\n</code></pre></p> <p>When you are ready to publish one or more DIDs, execute the <code>publish.sh</code> script by running the following command: <pre><code>\"$TRUSTCHAIN_REPO\"/scripts/publish.sh\n</code></pre></p> <p>This script will attempt to publish all of the DID operations (JSON files) that are found in the <code>$TRUSTCHAIN_DATA/operations/</code> directory. It does this by sending each of them to your ION server as an HTTP POST request. The response to each of these requests is checked for success (HTTP status code 200).</p> <p>If successful, the output should look something like this: <pre><code>Found 2 DID operations.\nPublishing:\n- create_operation_EiBvWFdG7JUVpGu4z0qTc7WkqerZSU-K7_osR8QVPMYciw.json \u2705\n- create_operation_EiDzJNlBiKahsykDcAfC1C6StUurvbIyERrkDBmWIXiPzg.json \u2705\nAll DID operations were published successfully\nFiles moved to the 'sent/' subdirectory\n</code></pre></p> <p>The script reports the outcome of each publication attempt. If any attempt failed, the HTTP error code will be reported along with the path to the output JSON file containing any error messages.</p> <p>Each JSON file will be moved to either the <code>sent/</code> or <code>failed/</code> subdirectory.</p> <p>After the <code>publish.sh</code> script has run, there will be some delay before the newly-published DID can be resolved. This is due to i) the ION publication mechanism, which supports batching of DID operations to reduce transaction fees, and ii) the Bitcoin network processing time. For more details, see the information panels below.</p> <p>Once the publication transaction has been processed, confirm that the DID was successfully published by attempting to resolve it using the CLI.</p> MainnetTestnet4Testnet3 (Deprecated) ION DID publication mechanism <p>The <code>publish.sh</code> script takes all of the DID operations in <code>$TRUSTCHAIN_DATA/operations/</code> and dispatches them to the local ION node for publishing. They are then placed in the collection of <code>queued-operations</code> inside ION's Mongo database.</p> <p>To view the contents of this database, open the MongoDB shell with this command: <pre><code>mongosh\n</code></pre> Then run the following MongoDB commands (omitting the <code>&gt;</code> prompt character) to select the database: <pre><code>&gt; ion-mainnet-core\n</code></pre> and check how many queued DID operations exist: <pre><code>&gt; db[\"queued-operations\"].countDocuments()\n</code></pre> The output from this command will usually be zero, indicating that there are no queued operations. Immediately after running the <code>publish.sh</code> script, the number of queued operations will increase to one (or more, if there were multiple files inside <code>$TRUSTCHAIN_DATA/operations/</code> when the script was executed).</p> <p>Periodically, ION will check if there are any queued operations and, if any exist, it will batch them together and publish them in a single Bitcoin operation. The frequency with which this check is performed can be controlled by setting the <code>batchingIntervalInSeconds</code> parameter, found in the ION core config file. To view this file, run: <pre><code>less $ION_CORE_CONFIG_FILE_PATH\n</code></pre></p> <p>The default batching interval is 600 seconds. This can be reduced by changing the value of the <code>batchingIntervalInSeconds</code> parameter and restarting ION.</p> Bitcoin network processing time <p>When a new (or updated) DID document is published, it will take some time for the Bitcoin network to process the relevant transaction so that it becomes visible to all other network participants.</p> <p>Only after this processing has finished will it be possible to resolve the DID using the Trustchain CLI <code>resolve</code> command.</p> <p>Typically, the processing time will be between 10 and 60 minutes, but it might be longer depending on factors such as the level of congestion on the Bitcoin network and the size of the fee inserted in the relevant transaction.</p> <p>Tip: Identifying your DID transaction</p> <p>While you are waiting for your DID to be published, you can track its progress by observing the Bitcoin wallet address used to publish the DID operation. Run this command to list your Bitcoin addresses: <pre><code>bitcoin-cli -rpcwallet=\"sidetreeDefaultWallet\" listreceivedbyaddress 1 true\n</code></pre> Then copy the first address in the list and paste it into the search bar at mempool.space.</p> <p>This search will return information about your Bitcoin address, including the number of confirmed transactions that have taken place and the unspent amount in the address (i.e. its current balance). Below the summary information will be a list showing every transaction associated with this address, including any unconfirmed transactions.</p> <p>Assuming the ION publication mechanism has executed (see the panel above), the first transaction in the list will be the new one that was created by that process.</p> <p>Click on the first transaction ID (this is a long string of hexadecimal characters that uniquely identifies the transactions). This takes you to a new page with details about that particular transaction.</p> <p>Check the \"status\" of the transaction. If it is marked as \"Unconfirmed\", this indicates that it has not yet been processed by the Bitcoin network. In that case it will not yet be possible to resolve the new DID.</p> <p>By refreshing this page, you can check its progress. When the transaction has been processed its status will change to \"\\(n\\) Confirmations\", where \\(n\\) is the number of Bitcoin blocks mined since the one containing this transaction.</p> <p>As soon as the transaction has one or more confirmations, it should be possible to resolve the newly-published DID.</p> <p>If your are publishing a root DID, make a note of the transaction ID so you can easily find it later. You should also make a note of the transactions's timestamp (i.e. the exact date &amp; time that it was confirmed). The timestamp can be found on the same page as the transaction status on mempool.space.</p> ION DID publication mechanism <p>The <code>publish.sh</code> script takes all of the DID operations in <code>$TRUSTCHAIN_DATA/operations/</code> and dispatches them to the local ION node for publishing. They are then placed in the collection of <code>queued-operations</code> inside ION's Mongo database.</p> <p>To view the contents of this database, open the MongoDB shell with this command: <pre><code>mongosh\n</code></pre> Then run the following MongoDB commands (omitting the <code>&gt;</code> prompt character) to select the database: <pre><code>&gt; use ion-testnet-core\n</code></pre> and check how many queued DID operations exist: <pre><code>&gt; db[\"queued-operations\"].countDocuments()\n</code></pre> The output from this command will usually be zero, indicating that there are no queued operations. Immediately after running the <code>publish.sh</code> script, the number of queued operations will increase to one (or more, if there were multiple files inside <code>$TRUSTCHAIN_DATA/operations/</code> when the script was executed).</p> <p>Periodically, ION will check if there are any queued operations and, if any exist, it will batch them together and publish them in a single Bitcoin operation. The frequency with which this check is performed can be controlled by setting the <code>batchingIntervalInSeconds</code> parameter, found in the ION core config file. To view this file, run: <pre><code>less $ION_CORE_CONFIG_FILE_PATH\n</code></pre></p> <p>The default batching interval is 600 seconds. This can be reduced by changing the value of the <code>batchingIntervalInSeconds</code> parameter and restarting ION.</p> Bitcoin network processing time <p>When a new (or updated) DID document is published, it will take some time for the Bitcoin network to process the relevant transaction so that it becomes visible to all other network participants.</p> <p>Only after this processing has finished will it be possible to resolve the DID using the Trustchain CLI <code>resolve</code> command.</p> <p>Typically, the processing time will be between 10 and 60 minutes, but it might be longer depending on factors such as the level of congestion on the Bitcoin network and the size of the fee inserted in the relevant transaction.</p> <p>Tip: Identifying your DID transaction</p> <p>While you are waiting for your DID to be published, you can track its progress by observing the Bitcoin wallet address used to publish the DID operation. Run this command to list your Bitcoin addresses: <pre><code>bitcoin-cli -rpcwallet=\"sidetreeDefaultWallet\" listreceivedbyaddress 1 true\n</code></pre> Then copy the first address in the list and paste it into the search bar at mempool.space.</p> <p>This search will return information about your Bitcoin address, including the number of confirmed transactions that have taken place and the unspent amount in the address (i.e. its current balance). Below the summary information will be a list showing every transaction associated with this address, including any unconfirmed transactions.</p> <p>Assuming the ION publication mechanism has executed (see the panel above), the first transaction in the list will be the new one that was created by that process.</p> <p>Click on the first transaction ID (this is a long string of hexadecimal characters that uniquely identifies the transactions). This takes you to a new page with details about that particular transaction.</p> <p>Check the \"status\" of the transaction. If it is marked as \"Unconfirmed\", this indicates that it has not yet been processed by the Bitcoin network. In that case it will not yet be possible to resolve the new DID.</p> <p>By refreshing this page, you can check its progress. When the transaction has been processed its status will change to \"\\(n\\) Confirmations\", where \\(n\\) is the number of Bitcoin blocks mined since the one containing this transaction.</p> <p>As soon as the transaction has one or more confirmations, it should be possible to resolve the newly-published DID.</p> <p>If your are publishing a root DID, make a note of the transaction ID so you can easily find it later. You should also make a note of the transactions's timestamp (i.e. the exact date &amp; time that it was confirmed). The timestamp can be found on the same page as the transaction status on mempool.space.</p> ION DID publication mechanism <p>The <code>publish.sh</code> script takes all of the DID operations in <code>$TRUSTCHAIN_DATA/operations/</code> and dispatches them to the local ION node for publishing. They are then placed in the collection of <code>queued-operations</code> inside ION's Mongo database.</p> <p>To view the contents of this database, open the MongoDB shell with this command: <pre><code>mongosh\n</code></pre> Then run the following MongoDB commands (omitting the <code>&gt;</code> prompt character) to select the database: <pre><code>&gt; use ion-testnet-core\n</code></pre> and check how many queued DID operations exist: <pre><code>&gt; db[\"queued-operations\"].countDocuments()\n</code></pre> The output from this command will usually be zero, indicating that there are no queued operations. Immediately after running the <code>publish.sh</code> script, the number of queued operations will increase to one (or more, if there were multiple files inside <code>$TRUSTCHAIN_DATA/operations/</code> when the script was executed).</p> <p>Periodically, ION will check if there are any queued operations and, if any exist, it will batch them together and publish them in a single Bitcoin operation. The frequency with which this check is performed can be controlled by setting the <code>batchingIntervalInSeconds</code> parameter, found in the ION core config file. To view this file, run: <pre><code>less $ION_CORE_CONFIG_FILE_PATH\n</code></pre></p> <p>The default batching interval is 600 seconds. This can be reduced by changing the value of the <code>batchingIntervalInSeconds</code> parameter and restarting ION.</p> Bitcoin network processing time <p>When a new (or updated) DID document is published, it will take some time for the Bitcoin network to process the relevant transaction so that it becomes visible to all other network participants.</p> <p>Only after this processing has finished will it be possible to resolve the DID using the Trustchain CLI <code>resolve</code> command.</p> <p>Typically, the processing time will be between 10 and 60 minutes, but it might be longer depending on factors such as the level of congestion on the Bitcoin network and the size of the fee inserted in the relevant transaction.</p> <p>Tip: Identifying your DID transaction</p> <p>While you are waiting for your DID to be published, you can track its progress by observing the Bitcoin wallet address used to publish the DID operation. Run this command to list your Bitcoin addresses: <pre><code>bitcoin-cli -rpcwallet=\"sidetreeDefaultWallet\" listreceivedbyaddress 1 true\n</code></pre> Then copy the first address in the list and paste it into the search bar at mempool.space.</p> <p>This search will return information about your Bitcoin address, including the number of confirmed transactions that have taken place and the unspent amount in the address (i.e. its current balance). Below the summary information will be a list showing every transaction associated with this address, including any unconfirmed transactions.</p> <p>Assuming the ION publication mechanism has executed (see the panel above), the first transaction in the list will be the new one that was created by that process.</p> <p>Click on the first transaction ID (this is a long string of hexadecimal characters that uniquely identifies the transactions). This takes you to a new page with details about that particular transaction.</p> <p>Check the \"status\" of the transaction. If it is marked as \"Unconfirmed\", this indicates that it has not yet been processed by the Bitcoin network. In that case it will not yet be possible to resolve the new DID.</p> <p>By refreshing this page, you can check its progress. When the transaction has been processed its status will change to \"\\(n\\) Confirmations\", where \\(n\\) is the number of Bitcoin blocks mined since the one containing this transaction.</p> <p>As soon as the transaction has one or more confirmations, it should be possible to resolve the newly-published DID.</p> <p>If your are publishing a root DID, make a note of the transaction ID so you can easily find it later. You should also make a note of the transactions's timestamp (i.e. the exact date &amp; time that it was confirmed). The timestamp can be found on the same page as the transaction status on mempool.space.</p> <p>Tip: Batching DID operations</p> <p>To save time and reduce transaction fees, multiple DID operations can be batched into a single Bitcoin transaction. In fact, ION supports batching of up to 10,000 operations per transaction.</p> <p>To perform batching, simply repeat the create operation as many times as you like before running the <code>publish.sh</code> script. Then run the script once to publish all operations in a single batch.</p> <p>The only exception to this rule is that the root DID must not be published in a batched transaction. It must be the unique DID operation associated with the transaction in which it is published. The reason for this condition is to enable fast and efficient scanning of the Bitcoin blockchain to identify potential root DID operations.</p>"},{"location":"usage/#downstream-did-issuance","title":"Downstream DID Issuance","text":"<p>This process must be carried out by the DID controller, that is, the legal entity whose attestation will appear on the downstream DID. The DID controller must itself be the subject of another DID document that is already published. We refer to the controller's DID as the upstream DID (uDID).</p> <p>Challenge-response protocol</p> <p>The interaction between the upstream and downstream entities, when issuing a new downstream DID, must be performed carefully so that the dDID controller (upstream entity) can be confident that the information included in the downstream DID document is correct, before attesting to it.</p> <p>The proper way to manage this interaction is via a challenge-response protocol, that includes rigorous checks of both the identity of the legal entities involved and of the dDID document content.</p> <p>The latest version of the Trustchain CLI includes such a challenge-response protocol. In earlier versions, dDID issuance is a manual process, as described here.</p> <p>Issuing a downstream DID is a two-step process. The first step is for the dDID subject to publish their (regular) DID by following the steps in the DID Issuance section above.</p> <p>The second step is for the dDID controller to attest to the DID by adding their signature and re-publishing an updated DID document.</p>"},{"location":"usage/#attest-to-the-ddid","title":"Attest to the dDID","text":"<p>This step must be carried out by the dDID issuer.</p> <p>We assume that the downsteam legal entity has published their candidate dDID document and shared their candidate dDID (string identifier) with the controller. In the following commands, replace <code>&lt;CANDIDATE_dDID&gt;</code> with the candidate dDID and <code>&lt;uDID&gt;</code> with the controller's DID.</p> <p>First check that the candidate dDID can be successfully resolved: <pre><code>trustchain-cli did resolve --did &lt;CANDIDATE_dDID&gt;\n</code></pre></p> <p>Next, use the CLI to attest to the dDID: <pre><code>trustchain-cli did attest --did &lt;uDID&gt; --controlled_did &lt;CANDIDATE_dDID&gt;\n</code></pre></p>"},{"location":"usage/#publish-the-updated-ddid-document","title":"Publish the updated dDID document","text":"<p>To publish the updated dDID document, containing the controller's attestation, follow exactly the same steps as above for publishing a regular DID document.</p> <p>Tip: Batching DID update operations</p> <p>As mentioned above, DID operations can be batched to save time and money. This remains true for the update operations used to convert a DID into a dDID. The only constraint is that create and update operations for the same DID cannot be batched into the same transaction, since to perform the attestion the DID must have already been published.</p> <p>Therefore, when issuing multiple dDIDs the most efficient approach is to batch together as many create operations as possible, publish them all in a single transaction, wait for that to be processed, and then batch together as many update operations as possible in a subsequent transaction.</p>"},{"location":"usage/#downstream-did-verification","title":"Downstream DID Verification","text":"<p>To verify a downstream DID, run the following command with the relevant <code>&lt;dDID&gt;</code> identifier: <pre><code>trustchain-cli did verify --did &lt;dDID&gt;\n</code></pre> The Trustchain CLI will perform the following verification process and report the result:</p> <ol> <li>Resolve the given dDID document.</li> <li>Identify the controller's uDID from the dDID metadata. If no controller is found, the verification fails.</li> <li>If the uDID is itself a downstream DID, repeat steps 1 &amp; 2 until reaching the root DID.</li> <li>Verify that the timestamp on the root DID exactly matches the configured <code>root_event_time</code> parameter. If the timestamp does not match, the verification fails.</li> <li>Starting at the root DID, descend down the DID chain and verify each attestation signature using the public key from the next upstream DID document. If any signature is invalid, the verification fails.</li> <li>If all of the attestation signatures in the chain are valid, the verification is successful.</li> </ol> <p>This process ensures that the exact content of the downstream DID (including the public keys of the downstream legal entity) has been attested to by a recognised upstream entity, whose own public keys have themselves been attested to in a chain of signatures leading back to the root DID, whose exact time of publication has also been verified.</p>"},{"location":"usage/#credential-issuance","title":"Credential Issuance","text":"<p>This section is under construction.</p>"},{"location":"usage/#credential-verification","title":"Credential Verification","text":"<p>This section is under construction.</p> <p> </p>"},{"location":"use-cases/","title":"Use Cases","text":"<p>Trustchain enables communities of any size to establish their own trustworthy public key infrastructure (PKI), without expensive setup costs or reliance on any third parties. Since PKI is fundamental digital infrastructure, it opens the door to a wide variety of use cases.</p> <p>Here we describe four types of application that can be supported by Trustchain. Each represents an entire category of possible use cases.</p>"},{"location":"use-cases/#verifiable-credentials","title":"Verifiable Credentials","text":"<p>Trustchain is designed to support ecosystems of verifiable digital credentials that put the user in control of their own data, providing the benefits of digital ID without the risks to privacy and data security. This solution is based on the principle that credential-issuing institutions ought to be uniquely and transparently identifiable, while individual users need not be.</p> <p>We adopt the W3C standard for Verifiable Credentials, which specifies their technical details and also provides a useful introduction to the key concepts. This related document from the W3C focusses on the numerous use cases presented by the Verifiable Credentials model.</p>"},{"location":"use-cases/#data-provenance","title":"Data Provenance","text":"<p>Trustchain enables anybody to check the authenticity and provenance of data and digital media by verifying its integrity and the identity of its original source.</p> <p>Every news article, every image, every video could be signed by the original publisher, to prove it has not been modified or tampered with since its release. And because Trustchain is open and decentralised, this ability is available to everyone, not just large content providers.</p>"},{"location":"use-cases/#verifiable-urls","title":"Verifiable URLs","text":"<p>There is currently no foolproof way to verify that a web page is legitimate before visiting it. This is a particular problem when URLs are displayed in QR codes at payment locations such as car parks or EV charging points, so-called QR code scams.</p> <p>By tying together URLs and institutional identity, in a cryptographically verifiable way, Trustchain can provide robust defence against all types of phishing attacks, including QR code scams.</p>"},{"location":"use-cases/#secure-communication","title":"Secure Communication","text":"<p>Public Key Infrastructure is used on the Web to enable secure communication between clients and servers. Without this technology, online commerce and many services, such as internet banking, would be impossible.</p> <p>However, all too often data sharing practices remain inefficient and insecure. For instance, when making loan or mortgage applications individuals often share sensitive information, such as bank statements, over insecure channels and in plain text. When provenance is required, it is common to resort to hard copies with physical signatures or stamps.</p> <p>Trustchain provides a general solution to the problem of secure communication, including data sharing. It does this by creating a trustworthy PKI in which public key certificates refer to recognisable legal entities themselves (not merely their web domains), and different keys are available for different purposes. In that scenario, all data exchanges can be encrypted and their source verifiable, paving the way for a truly digital economy.</p> <p> </p>"}]}